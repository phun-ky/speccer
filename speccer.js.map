{"version":3,"file":"speccer.js","sources":["src/types/enums/area.ts","src/utils/area.ts","src/utils/typeof/index.ts","src/utils/wait.ts","src/utils/coords.ts","src/utils/xy.ts","src/utils/intrinsic-coords.ts","src/utils/get-coords-pair-from-objects.ts","src/utils/bezier.ts","src/utils/direction-of-element.ts","src/utils/angle.ts","src/utils/cardinal.ts","src/utils/id.ts","src/utils/styles.ts","src/utils/classes/DrawSVGCurlyBracket.ts","src/utils/classes/DrawSVGLine.ts","src/utils/classnames.ts","src/utils/constants.ts","src/utils/css.ts","src/utils/position.ts","src/features/dissect/utils/styles.ts","src/features/dissect/index.ts","src/features/measure/index.ts","src/features/spacing/utils/position.ts","src/features/spacing/index.ts","src/utils/resize.ts","src/utils/debounce.ts","src/config/browser.ts","src/features/mark/index.ts","src/utils/number.ts","src/features/typography/index.ts","src/features/typography/utils/template.ts","src/features/typography/utils/position.ts","src/main.ts","src/utils/node.ts"],"sourcesContent":["/* eslint-disable no-unused-vars */\n\n/**\n * Enum representing different areas in Speccer.\n */\nexport enum SpeccerAreaEnum {\n  Empty = '', // Represents an empty area\n  Left = 'left', // Represents the left area\n  Right = 'right', // Represents the right area\n  Bottom = 'bottom', // Represents the bottom area\n  Top = 'top' // Represents the top area\n}\n\n/**\n * Enum representing different areas in Dissect.\n */\nexport enum DissectAreaEnum {\n  Outline = 'outline', // Represents an outline area\n  Enclose = 'enclose', // Represents an enclose area\n  Full = 'full', // Represents a full area\n  Left = 'left', // Represents the left area\n  Right = 'right', // Represents the right area\n  Bottom = 'bottom', // Represents the bottom area\n  Top = 'top', // Represents the top area\n  SVG = 'svg', // Represents an SVG area\n  Curly = 'curly' // Represents a curly area\n}\n\n/**\n * Enum representing different measurement areas.\n */\nexport enum MeasureAreaEnum {\n  Width = 'width', // Represents the width measurement area\n  Height = 'height', // Represents the height measurement area\n  Left = 'left', // Represents the left measurement area\n  Right = 'right', // Represents the right measurement area\n  Bottom = 'bottom', // Represents the bottom measurement area\n  Top = 'top' // Represents the top measurement area\n}\n","import { DissectAreaEnum, MeasureAreaEnum } from '../types/enums/area';\n\n/**\n * Splits a string containing areas into an array of strings.\n *\n * @param areaString - The string containing areas.\n * @returns An array of area strings.\n *\n * @example\n * ```ts\n * const areas = getAreasFromString('left right top');\n * // areas: ['left', 'right', 'top']\n * ```\n */\nexport const getAreasFromString = (areaString: string): string[] =>\n  areaString.split(' ');\n\n/**\n * Checks if 'left' area is present in the provided areaString.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if 'left' is present, otherwise `false`.\n */\nexport const isLeftArea = (areaString: string): boolean => {\n  const areas = getAreasFromString(areaString);\n\n  return areas.includes(DissectAreaEnum.Left);\n};\n\n/**\n * Checks if 'right' area is present in the provided areaString.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if 'right' is present, otherwise `false`.\n */\nexport const isRightArea = (areaString: string): boolean => {\n  const areas = getAreasFromString(areaString);\n\n  return areas.includes(DissectAreaEnum.Right);\n};\n\n/**\n * Checks if 'top' area is present in the provided areaString.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if 'top' is present, otherwise `false`.\n */\nexport const isTopArea = (areaString: string): boolean => {\n  const areas = getAreasFromString(areaString);\n\n  return areas.includes(DissectAreaEnum.Top);\n};\n\n/**\n * Checks if 'bottom' area is present in the provided areaString.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if 'bottom' is present, otherwise `false`.\n */\nexport const isBottomArea = (areaString: string): boolean => {\n  const areas = getAreasFromString(areaString);\n\n  return areas.includes(DissectAreaEnum.Bottom);\n};\n\n/**\n * Checks if 'full' area is present in the provided areaString.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if 'full' is present, otherwise `false`.\n */\nexport const isFullArea = (areaString: string): boolean => {\n  const areas = getAreasFromString(areaString);\n\n  return areas.includes(DissectAreaEnum.Full);\n};\n\n/**\n * Checks if 'enclose' area is present in the provided areaString.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if 'enclose' is present, otherwise `false`.\n */\nexport const isEncloseArea = (areaString: string): boolean => {\n  const areas = getAreasFromString(areaString);\n\n  return areas.includes(DissectAreaEnum.Enclose);\n};\n\n/**\n * Checks if 'height' area is present in the provided areaString.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if 'height' is present, otherwise `false`.\n */\nexport const isHeightArea = (areaString: string): boolean => {\n  const areas = getAreasFromString(areaString);\n\n  return areas.includes(MeasureAreaEnum.Height);\n};\n\n/**\n * Checks if 'width' area is present in the provided areaString.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if 'width' is present, otherwise `false`.\n */\nexport const isWidthArea = (areaString: string): boolean => {\n  const areas = getAreasFromString(areaString);\n\n  return areas.includes(MeasureAreaEnum.Width);\n};\n\n/**\n * Checks if the provided areaString contains SVG-related areas.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if any SVG-related area is present, otherwise `false`.\n */\nexport const useSVG = (areaString: string): boolean =>\n  areaString.includes(DissectAreaEnum.SVG);\n\n/**\n * Checks if the provided areaString contains 'curly' and 'full' areas.\n *\n * @param areaString - The string containing areas.\n * @returns `true` if both 'curly' and 'full' are present, otherwise `false`.\n */\nexport const isCurly = (areaString: string): boolean =>\n  areaString.includes(DissectAreaEnum.Curly) &&\n  areaString.includes(DissectAreaEnum.Full);\n","/* eslint-disable import/no-unused-modules */\nexport const isString = (variable: unknown) => typeof variable === 'string';\n\nexport const isNotString = (variable: unknown) => !isString(variable);\n\nexport const isNumber = (variable: unknown) => typeof variable === 'number';\n\nexport const isNotNumber = (variable: unknown) => !isNumber(variable);\n\nexport const isBoolean = (variable: unknown) => typeof variable === 'boolean';\n\nexport const isNotBoolean = (variable: unknown) => !isBoolean(variable);\n\nexport const isUndefined = (variable: unknown) => typeof variable === 'undefined';\n\nexport const isNotUndefined = (variable: unknown) => !isNotUndefined(variable);\n","/**\n * Waits for the specified amount of time in milliseconds.\n *\n * @param {number} ms - The number of milliseconds to wait.\n * @returns {Promise<void>} - A Promise that resolves after the specified time.\n *\n * @example\n * ```ts\n * // Wait for 1 second (1000 milliseconds)\n * await waitFor(1000);\n * ```\n */\nexport const waitFor = (ms: number): Promise<void> =>\n  new Promise<void>((resolve) => setTimeout(resolve, ms));\n\n/**\n * Waits for the next animation frame using requestAnimationFrame.\n *\n * @returns {Promise<number>} - A Promise that resolves with the timestamp of the next animation frame.\n *\n * @example\n * ```ts\n * // Wait for the next animation frame and get the rect\n * await waitForFrame();\n * const rect = el.getBoundingClientRect();\n * // Wait for the next animation frame and get the timestamp\n * const timestamp = await waitForFrame();\n * ```\n */\nexport const waitForFrame = (): Promise<number> =>\n  new Promise<number>(requestAnimationFrame);\n","/**\n * A set of functions to retrieve specific coordinates from a DOMRect.\n */\nexport const coords = {\n  /**\n   * Get the top coordinate of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the top coordinate from.\n   * @returns {number} The top coordinate.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const topCoordinate = coords.top(rect);\n   * ```\n   */\n  top: (rect: DOMRect): number => rect.top,\n\n  /**\n   * Get the right coordinate of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the right coordinate from.\n   * @returns {number} The right coordinate.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const rightCoordinate = coords.right(rect);\n   * ```\n   */\n  right: (rect: DOMRect): number => rect.left + rect.width,\n\n  /**\n   * Get the bottom coordinate of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the bottom coordinate from.\n   * @returns {number} The bottom coordinate.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const bottomCoordinate = coords.bottom(rect);\n   * ```\n   */\n  bottom: (rect: DOMRect): number => rect.top + rect.height,\n\n  /**\n   * Get the left coordinate of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the left coordinate from.\n   * @returns {number} The left coordinate.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const leftCoordinate = coords.left(rect);\n   * ```\n   */\n  left: (rect: DOMRect): number => rect.left,\n\n  /**\n   * Get the x-coordinate of the center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the x-coordinate of the center from.\n   * @returns {number} The x-coordinate of the center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const centerXCoordinate = coords.center_x(rect);\n   * ```\n   */\n  center_x: (rect: DOMRect): number => rect.left + rect.width / 2,\n\n  /**\n   * Get the y-coordinate of the center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the y-coordinate of the center from.\n   * @returns {number} The y-coordinate of the center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const centerYCoordinate = coords.center_y(rect);\n   * ```\n   */\n  center_y: (rect: DOMRect): number => rect.top + rect.height / 2\n};\n","import { coords } from './coords';\n\n/**\n * Object containing functions to retrieve specific x and y coordinates from a DOMRect.\n */\nexport const xy = {\n  /**\n   * Get the x and y coordinates of the center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const centerCoordinates = xy.center(rect);\n   * // centerCoordinates.x and centerCoordinates.y will contain the coordinates\n   * ```\n   */\n  center: (rect: DOMRect): { x: number; y: number } => ({\n    x: coords.center_x(rect),\n    y: coords.center_y(rect)\n  }),\n\n  /**\n   * Get the x and y coordinates of the top center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the top center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const topCenterCoordinates = xy.top(rect);\n   * // topCenterCoordinates.x and topCenterCoordinates.y will contain the coordinates\n   * ```\n   */\n  top: (rect: DOMRect): { x: number; y: number } => ({\n    x: coords.center_x(rect),\n    y: coords.top(rect)\n  }),\n\n  /**\n   * Get the x and y coordinates of the right center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the right center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const rightCenterCoordinates = xy.right(rect);\n   * // rightCenterCoordinates.x and rightCenterCoordinates.y will contain the coordinates\n   * ```\n   */\n  right: (rect: DOMRect): { x: number; y: number } => ({\n    x: coords.right(rect),\n    y: coords.center_y(rect)\n  }),\n\n  /**\n   * Get the x and y coordinates of the bottom center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the bottom center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const bottomCenterCoordinates = xy.bottom(rect);\n   * // bottomCenterCoordinates.x and bottomCenterCoordinates.y will contain the coordinates\n   * ```\n   */\n  bottom: (rect: DOMRect): { x: number; y: number } => ({\n    x: coords.center_x(rect),\n    y: coords.bottom(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the left of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the left.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const leftCoordinates = xy.left(rect);\n   * // leftCoordinates.x and leftCoordinates.y will contain the coordinates\n   * ```\n   */\n  left: (rect: DOMRect) => ({ x: coords.left(rect), y: coords.center_y(rect) }),\n  'right-top': (rect: DOMRect) => ({\n    x: coords.right(rect),\n    y: coords.top(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the right bottom of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the right bottom.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const rightBottomCoordinates = xy['right-bottom'](rect);\n   * // rightBottomCoordinates.x and rightBottomCoordinates.y will contain the coordinates\n   * ```\n   */\n  'right-bottom': (rect: DOMRect) => ({\n    x: coords.right(rect),\n    y: coords.bottom(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the left top of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the left top.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const leftTop = xy['left-top'](rect);\n   * // leftTop.x and leftTop.y will contain the coordinates\n   * ```\n   */\n  'left-top': (rect: DOMRect) => ({\n    x: coords.left(rect),\n    y: coords.top(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the left bottom of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the left bottom.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const leftBottomCoordinates = xy['left-bottom'](rect);\n   * // leftBottomCoordinates.x and leftBottomCoordinates.y will contain the coordinates\n   * ```\n   */\n  'left-bottom': (rect: DOMRect) => ({\n    x: coords.left(rect),\n    y: coords.bottom(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the top left of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the top left.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const topLeftCoordinates = xy['top-left'](rect);\n   * // topLeftCoordinates.x and topLeftCoordinates.y will contain the coordinates\n   * ```\n   */\n  'top-left': (rect: DOMRect) => ({\n    x: coords.left(rect),\n    y: coords.top(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the top right of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the top right.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const topRightCoordinates = xy['top-right'](rect);\n   * // topRightCoordinates.x and topRightCoordinates.y will contain the coordinates\n   * ```\n   */\n  'top-right': (rect: DOMRect) => ({\n    x: coords.right(rect),\n    y: coords.top(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the bottom left of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the bottom left.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const bottomLeftCoordinates = xy['bottom-left'](rect);\n   * // bottomLeftCoordinates.x and bottomLeftCoordinates.y will contain the coordinates\n   * ```\n   */\n  'bottom-left': (rect: DOMRect) => ({\n    x: coords.left(rect),\n    y: coords.bottom(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the bottom right of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the bottom right.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const bottomRight = xy['bottom-right'](rect);\n   * // bottomRight.x and bottomRight.y will contain the coordinates\n   * ```\n   */\n  'bottom-right': (rect: DOMRect) => ({\n    x: coords.right(rect),\n    y: coords.bottom(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the top center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the top center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const topCenterCoordinates = xy['top-center'](rect);\n   * // topCenterCoordinates.x and topCenterCoordinates.y will contain the coordinates\n   * ```\n   */\n  'top-center': (rect: DOMRect) => ({\n    x: coords.center_x(rect),\n    y: coords.top(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the right center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the right center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const rightCenterCoordinates = xy['right-center'](rect);\n   * // rightCenterCoordinates.x and rightCenterCoordinates.y will contain the coordinates\n   * ```\n   */\n  'right-center': (rect: DOMRect) => ({\n    x: coords.right(rect),\n    y: coords.center_y(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the bottom center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the bottom center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const bottomCenterCoordinates = xy['bottom-center'](rect);\n   * // bottomCenterCoordinates.x and bottomCenterCoordinates.y will contain the coordinates\n   * ```\n   */\n  'bottom-center': (rect: DOMRect) => ({\n    x: coords.center_x(rect),\n    y: coords.bottom(rect)\n  }),\n  /**\n   * Get the x and y coordinates of the left center of a DOMRect.\n   * @param {DOMRect} rect - The DOMRect to retrieve the coordinates from.\n   * @returns {{ x: number, y: number }} The x and y coordinates of the left center.\n   * @example\n   * ```ts\n   * const rect = element.getBoundingClientRect();\n   * const leftCenterCoordinates = xy['left-center'](rect);\n   * // leftCenterCoordinates.x and leftCenterCoordinates.y will contain the coordinates\n   * ```\n   */\n  'left-center': (rect: DOMRect) => ({\n    x: coords.left(rect),\n    y: coords.center_y(rect)\n  })\n};\n","import { isNotString } from './typeof';\nimport { waitForFrame } from './wait';\nimport { xy } from './xy';\n\n/**\n * Get the intrinsic coordinates of an element based on a specified position.\n *\n * @param {HTMLElement} el - The HTML element.\n * @param {string} [pos='center'] - The position to use.\n * @throws {Error} No position given.\n * @throws {Error} The position given is not the required type.\n * @returns {Promise<{ x: number, y: number }>} - An object containing the coordinates.\n * @example\n * ```ts\n * // Get intrinsic coordinates for an element\n * const element = document.getElementById('example');\n * const coordinates = await intrinsic_coords(element, 'top-left');\n * ```\n */\nexport const intrinsic_coords = async (\n  el: HTMLElement,\n  pos = 'center'\n): Promise<{ x: number; y: number }> => {\n  if (!pos) throw Error('No position given');\n\n  if (isNotString(pos))\n    throw Error(\n      `The position given is not the required type: pos: ${typeof pos}`\n    );\n\n  const _allowed_positions = [\n    'center',\n    'left',\n    'right',\n    'top',\n    'bottom',\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n    'top-left',\n    'top-right',\n    'bottom-left',\n    'bottom-right',\n    'top-center',\n    'right-center',\n    'bottom-center',\n    'left-center'\n  ];\n\n  if (!_allowed_positions.includes(pos))\n    throw Error(\n      `The position given does not match allowed positions to use! Valid positions are: ${_allowed_positions.join(\n        ', '\n      )}`\n    );\n\n  await waitForFrame();\n\n  const _el_rect = el.getBoundingClientRect();\n\n  return xy[pos](_el_rect);\n};\n","import { intrinsic_coords } from './intrinsic-coords';\n\n/**\n * Get the x and y coordinates of two elements and return them as an object.\n *\n * @param {HTMLElement} el1 - The first HTML element.\n * @param {HTMLElement} el2 - The second HTML element.\n * @param {string} [pos1='center'] - The position to use for the first element.\n * @param {string} [pos2='center'] - The position to use for the second element.\n * @throws {Error} No element given.\n * @returns {Promise<{ x1: number, y1: number, x2: number, y2: number }>} - An object containing the coordinates.\n * @example\n * ```ts\n * // Get coordinates for two elements\n * const element1 = document.getElementById('element1');\n * const element2 = document.getElementById('element2');\n * const coordinates = await get_coords_pair_from_objects(element1, element2);\n * ```\n */\nexport const getCoordsPairFromObjects = async (\n  el1: HTMLElement,\n  el2: HTMLElement,\n  pos1 = 'center',\n  pos2 = 'center'\n): Promise<{ x1: number; y1: number; x2: number; y2: number }> => {\n  if (!el1 || !el2) throw Error('No element given');\n\n  const { x: x1, y: y1 } = await intrinsic_coords(el1, pos1);\n  const { x: x2, y: y2 } = await intrinsic_coords(el2, pos2);\n\n  return {\n    x1,\n    y1,\n    x2,\n    y2\n  };\n};\n","import {\n  BezierPathOptionsType,\n  CreateCoordinatesForCurveCoordParamType,\n  CreateCoordinatesForCurveOptionsParamType,\n  CurlyBezierPathOptionsType\n} from '../types/bezier';\n\nimport { getCoordsPairFromObjects } from './get-coords-pair-from-objects';\n\n/**\n * Calculates coordinates for a Bezier curve between two points.\n *\n * @param coords - The coordinates of the start and end points.\n * @param options - Options for controlling the curve's shape.\n * @returns Coordinates for the Bezier curve.\n *\n * @example\n * ```ts\n * const coordinates = createBezierCurveCoordinates(\n *   { x1: 0, x2: 100, y1: 0, y2: 100 },\n *   { direct: true, firstSet: true, direction: 'west' }\n * );\n * ```\n */\nexport const createBezierCurveCoordinates = (\n  coords: CreateCoordinatesForCurveCoordParamType,\n  options: CreateCoordinatesForCurveOptionsParamType\n) => {\n  const { x1, x2, y1, y2 } = coords;\n  const { direct = false, firstSet = false, direction } = options;\n  const firstPoint = { x: x1, y: y1 }; // The first point of the curve\n  const lastPoint = { x: x2, y: y2 }; // The last point of the curve\n\n  let firstControl = { x: x1 + (x2 - x1) / 2, y: y1 }; // Control point for the first point\n  let lastControl = { x: x1 + (x2 - x1) / 2, y: y2 }; // Control point for the last point\n\n  if (direct) {\n    if (firstSet) {\n      if (direction === 'west') {\n        firstControl = { x: x1 - 32, y: y1 - 16 / 2 };\n        lastControl = { x: x2 + 32, y: y2 };\n      } else if (direction === 'south') {\n        firstControl = { x: x1 - 16 / 2, y: y1 + 32 };\n        lastControl = { x: x2, y: y2 - 32 };\n      } else if (direction === 'east') {\n        firstControl = { x: x1 + 32, y: y1 - 16 / 2 };\n        lastControl = { x: x2 - 32, y: y2 };\n      } else {\n        firstControl = { x: x1 - 16 / 2, y: y1 - 32 };\n        lastControl = { x: x2, y: y2 + 32 };\n      }\n    } else {\n      if (direction === 'west') {\n        firstControl = { x: x1 - 32, y: y1 + 16 / 2 };\n        lastControl = { x: x2 + 32, y: y2 };\n      } else if (direction === 'south') {\n        firstControl = { x: x1 + 16 / 2, y: y1 + 32 };\n        lastControl = { x: x2, y: y2 - 32 };\n      } else if (direction === 'east') {\n        firstControl = { x: x1 + 32, y: y1 + 16 / 2 };\n        lastControl = { x: x2 - 32, y: y2 };\n      } else {\n        firstControl = { x: x1 + 16 / 2, y: y1 - 32 };\n        lastControl = { x: x2, y: y2 + 32 };\n      }\n    }\n  }\n\n  return {\n    firstPoint,\n    firstControl,\n    lastPoint,\n    lastControl\n  };\n};\n\n/**\n * Generates an SVG path for a curved line between two HTML elements.\n *\n * @param startEl - The starting HTML element.\n * @param stopEl - The ending HTML element.\n * @param options - Options for controlling the curved line.\n * @returns The SVG path string for the curved line.\n *\n * @example\n * ```ts\n * const svgPath = getCurlySVGPath(startElement, stopElement, {\n *   pos1: 'top',\n *   pos2: 'bottom',\n *   firstSet: true,\n *   direction: 'south',\n * });\n * ```\n */\nexport const getCurlySVGPath = async (\n  startEl: HTMLElement,\n  stopEl: HTMLElement,\n  options: CurlyBezierPathOptionsType\n) => {\n  const { pos1, pos2, firstSet = false, direction } = options;\n  const { x1, y1, x2, y2 } = await getCoordsPairFromObjects(\n    startEl,\n    stopEl,\n    pos1,\n    pos2\n  );\n  const x1modifier = 0;\n  const y1modifier = 0;\n\n  let x2modifier = 0;\n  let y2modifier = 0;\n\n  // Create a gap between the pin and the bracket center\n  if (direction === 'north') y2modifier = 8;\n  else if (direction === 'west') x2modifier = 8;\n  else if (direction === 'east') x2modifier = -8;\n  else if (direction === 'south') y2modifier = -8;\n\n  const { firstPoint, firstControl, lastControl, lastPoint } =\n    createBezierCurveCoordinates(\n      {\n        x1: x1 + x1modifier,\n        x2: x2 + x2modifier,\n        y1: y1 + y1modifier + document.documentElement.scrollTop,\n        y2: y2 + y2modifier + document.documentElement.scrollTop\n      },\n      {\n        direct: true,\n        firstSet,\n        direction\n      }\n    );\n\n  return (\n    `M ${firstPoint.x} ${firstPoint.y}` +\n    `C ${firstControl.x} ${firstControl.y}, ${lastControl.x} ${lastControl.y}, ${lastPoint.x} ${lastPoint.y}`\n  );\n};\n\n/**\n * Generates an SVG path for a straight line between two HTML elements.\n *\n * @param startEl - The starting HTML element.\n * @param stopEl - The ending HTML element.\n * @param options - Options for controlling the straight line.\n * @returns The SVG path string for the straight line.\n *\n * @example\n * ```ts\n * const svgPath = getSVGPath(startElement, stopElement, {\n *   pos1: 'left',\n *   pos2: 'right',\n * });\n * ```\n */\nexport const getSVGPath = async (\n  startEl: HTMLElement,\n  stopEl: HTMLElement,\n  options: BezierPathOptionsType\n) => {\n  const { pos1, pos2 } = options;\n  const { x1, y1, x2, y2 } = await getCoordsPairFromObjects(\n    startEl,\n    stopEl,\n    pos1,\n    pos2\n  );\n  const { firstPoint, firstControl, lastControl, lastPoint } =\n    createBezierCurveCoordinates({ x1, x2, y1, y2 }, { direction: '' });\n\n  return (\n    `M ${firstPoint.x} ${firstPoint.y}` +\n    `C ${firstControl.x} ${firstControl.y}, ${lastControl.x} ${lastControl.y}, ${lastPoint.x} ${lastPoint.y}`\n  );\n};\n\n/**\n * Returns positions for creating an SVG path based on a cardinal direction.\n *\n * @param direction - The cardinal direction ('east', 'west', 'south', 'north').\n * @returns Positions for creating an SVG path.\n *\n * @example\n * ```ts\n * const positions = getPositionsForSVGPath('east');\n * ```\n */\nexport const getPositionsForSVGPath = (direction: string) => {\n  let pos1: string;\n  let pos2: string;\n\n  switch (direction) {\n    case 'east':\n      pos1 = 'right';\n      pos2 = 'left';\n      break;\n    case 'south':\n      pos1 = 'bottom';\n      pos2 = 'top';\n      break;\n    case 'west':\n      pos1 = 'left';\n      pos2 = 'right';\n      break;\n    case 'north':\n    default:\n      pos1 = 'top';\n      pos2 = 'bottom';\n      break;\n  }\n\n  return { pos1, pos2 };\n};\n\n/**\n * Returns positions for creating an SVG path for a curved line based on a cardinal direction.\n *\n * @param direction - The cardinal direction ('east', 'west', 'south', 'north').\n * @returns Positions for creating an SVG path for a curved line.\n *\n * @example\n * ```ts\n * const positions = getPositionsForCurlySVGPath('west');\n * ```\n */\nexport const getPositionsForCurlySVGPath = (direction: string) => {\n  let path1pos1: string;\n  let path1pos2: string;\n  let path2pos1: string;\n  let path2pos2: string;\n\n  switch (direction) {\n    case 'east':\n      path1pos1 = 'right-top';\n      path1pos2 = 'left-center';\n      path2pos1 = 'right-bottom';\n      path2pos2 = 'left-center';\n      break;\n    case 'south':\n      path1pos1 = 'bottom-left';\n      path1pos2 = 'top-center';\n      path2pos1 = 'bottom-right';\n      path2pos2 = 'top-center';\n      break;\n    case 'west':\n      path1pos1 = 'left-top';\n      path1pos2 = 'right-center';\n      path2pos1 = 'left-bottom';\n      path2pos2 = 'right-center';\n      break;\n    case 'north':\n    default:\n      path1pos1 = 'top-left';\n      path1pos2 = 'bottom-center';\n      path2pos1 = 'top-right';\n      path2pos2 = 'bottom-center';\n      break;\n  }\n\n  return {\n    path1pos1,\n    path1pos2,\n    path2pos1,\n    path2pos2\n  };\n};\n","import { angle } from './angle';\nimport { cardinal_direction, cardinal_direction_crude } from './cardinal';\nimport { getCoordsPairFromObjects } from './get-coords-pair-from-objects';\n\n/**\n * Get the direction of an element based on its position relative to another element.\n *\n * @param {Object} options - Options for direction calculation.\n * @param {HTMLElement} options.start - The starting HTML element.\n * @param {HTMLElement} options.stop - The stopping HTML element.\n * @param {boolean} [options.crude=false] - If the direction should be calculated crudely (NSEW).\n * @returns {Promise<string>} - The calculated direction.\n * @example\n * ```ts\n * // Get the direction of one element relative to another\n * const startElement = document.getElementById('startElement');\n * const stopElement = document.getElementById('stopElement');\n * const direction = await direction_of_element({ start: startElement, stop: stopElement });\n * ```\n */\nexport const direction_of_element = async ({\n  start,\n  stop,\n  crude = false\n}: {\n  start: HTMLElement;\n  stop: HTMLElement;\n  crude?: boolean;\n}): Promise<string> => {\n  const { x1, y1, x2, y2 } = await getCoordsPairFromObjects(start, stop);\n  const _angle = angle(x1, y1, x2, y2);\n  const _direction = crude\n    ? cardinal_direction_crude(_angle)\n    : cardinal_direction(_angle);\n\n  return _direction;\n};\n","import { isNotNumber, isUndefined } from './typeof';\n\n/**\n * Returns the angle between two sets of coordinates.\n *\n * @param {number} cx - The x-coordinate of the first point.\n * @param {number} cy - The y-coordinate of the first point.\n * @param {number} ex - The x-coordinate of the second point.\n * @param {number} ey - The y-coordinate of the second point.\n * @param {boolean} [normalize=true] - If the angle output should be normalized to a value between 0° and 360°.\n * @throws {SyntaxError} Missing input for `angle`.\n * @throws {TypeError} Parameters for `angle` do not have the required type.\n * @returns {number} The angle between the given coordinates.\n * @example\n * ```ts\n * // Calculate the angle between two points\n * const angleValue = angle(0, 0, 3, 4);\n * ```\n */\nexport const angle = (\n  cx: number,\n  cy: number,\n  ex: number,\n  ey: number,\n  normalize = true\n): number => {\n  if (isUndefined(cx) || isUndefined(cy) || isUndefined(ex) || isUndefined(ey))\n    throw new SyntaxError('Missing input for `angle`');\n\n  if (isNotNumber(cx) || isNotNumber(cy) || isNotNumber(ex) || isNotNumber(ey))\n    throw TypeError(\n      `Parameters for \\`angle\\` do not have the required type. Requires number! Got: ${typeof cx} ${typeof cy} ${typeof ex} ${typeof ey}`\n    );\n\n  const dy = ey - cy;\n  const dx = ex - cx;\n\n  let theta = Math.atan2(dy, dx); // range (-PI, PI]\n\n  theta *= 180 / Math.PI; // radians to degrees, range (-180, 180]\n\n  if (normalize && theta < 0) theta += 360; // range [0, 360)\n\n  return theta;\n};\n","/* eslint no-console:0 */\n\n/**\n * Gives you the cardinal direction based on degrees.\n * Note: The degrees start at 0, which is EAST (originally, north should be 0, but here, north is 270),\n * and we travel clockwise.\n *\n * @param {number} degrees - The angle in degrees.\n * @throws {RangeError} Parameter cannot exceed 360.\n * @throws {RangeError} Parameter cannot be lower than 0.\n * @returns {string} - The cardinal direction.\n * @example\n * ```ts\n * // Get the cardinal direction for an angle in degrees\n * const direction = cardinal_direction(45);\n * ```\n */\nexport const cardinal_direction = (degrees: number): string => {\n  if (degrees > 360) throw new RangeError('Parameter cannot exceed 360');\n\n  if (degrees < 0) throw new RangeError('Parameter cannot be lower than 0');\n\n  if (degrees >= 0 && degrees <= 22.5) return 'east';\n  else if (degrees >= 22.5 && degrees <= 67.5) return 'south-east';\n  else if (degrees >= 67.5 && degrees <= 112.5) return 'south';\n  else if (degrees >= 112.5 && degrees <= 157.5) return 'south-west';\n  else if (degrees >= 157.5 && degrees <= 202.5) return 'west';\n  else if (degrees >= 202.5 && degrees <= 247.5) return 'north-west';\n  else if (degrees >= 247.5 && degrees <= 292.5) return 'north';\n  else if (degrees >= 292.5 && degrees <= 337.5) return 'north-east';\n  else return 'east';\n};\n\n/**\n * Gives you the cardinal direction based on degrees (crude version).\n * Note: The degrees start at 0, which is EAST (originally, north should be 0, but here, north is 270),\n * and we travel clockwise.\n *\n * @param {number} degrees - The angle in degrees.\n * @throws {RangeError} Parameter cannot exceed 360.\n * @throws {RangeError} Parameter cannot be lower than 0.\n * @returns {string} - The cardinal direction (NSEW).\n * @example\n * ```ts\n * // Get the cardinal direction (crude) for an angle in degrees\n * const direction = cardinal_direction_crude(45);\n * ```\n */\nexport const cardinal_direction_crude = (degrees: number): string => {\n  if (degrees > 360) throw new RangeError('Parameter cannot exceed 360');\n\n  if (degrees < 0) throw new RangeError('Parameter cannot be lower than 0');\n\n  if (degrees >= 45 && degrees <= 135) return 'south';\n  else if (degrees > 135 && degrees <= 225) return 'west';\n  else if (degrees > 225 && degrees <= 315) return 'north';\n  else return 'east';\n};\n","/* eslint no-console:0 */\n/**\n * Generates a unique ID consisting of an underscore followed by a random alphanumeric string.\n *\n * @returns {string} - A unique ID.\n *\n * @example\n * ```ts\n * // Generate a unique ID\n * const id = uniqueID();\n * console.log(id); // Example output: \"_abc123def\"\n * ```\n */\nexport const uniqueID = (): string =>\n  '_' + Math.random().toString(36).substring(2, 11);\n","/* eslint no-console:0 */\nimport { isBoolean, isNumber, isString } from './typeof';\nimport { waitForFrame } from './wait';\n\n/**\n * Adds CSS styles to an HTMLElement.\n *\n * @param {HTMLElement} el - The HTMLElement to apply styles to.\n * @param {object | { key: string; value: string }[]} styles - An object or an array of objects containing CSS styles to apply.\n * @returns {Promise<void>} - A Promise that resolves after styles are applied.\n *\n * @example\n * ```ts\n * // Apply styles as an object\n * const element = document.getElementById('my-element');\n * await add(element, { color: 'red', fontSize: '16px' });\n *\n * // Apply styles as an array of objects\n * const styles = [\n *   { key: 'color', value: 'blue' },\n *   { key: 'backgroundColor', value: 'yellow' }\n * ];\n * await add(element, styles);\n * ```\n */\nexport const add = async (\n  el: HTMLElement,\n  styles: object | { key: string; value: string }[]\n): Promise<void> => {\n  if (\n    !el ||\n    !styles ||\n    isString(styles) ||\n    isNumber(styles) ||\n    isBoolean(styles) ||\n    (Array.isArray(styles) && !styles.length) ||\n    (!Object.keys(styles).length && styles.constructor === Object)\n  )\n    return;\n\n  await waitForFrame();\n\n  if (Array.isArray(styles))\n    for (const style of styles) {\n      el.style[style.key] = style.value;\n    }\n  else\n    for (const key of Object.keys(styles)) {\n      el.style[key] = styles[key];\n    }\n};\n\n/**\n * Gets the computed CSS styles of an HTMLElement.\n *\n * @param {HTMLElement} el - The HTMLElement to get computed styles from.\n * @returns {Promise<CSSStyleDeclaration>} - A Promise that resolves with the computed CSS styles.\n *\n * @example\n * ```ts\n * // Get computed styles of an element\n * const element = document.getElementById('my-element');\n * const computedStyles = await get(element);\n * console.log(computedStyles.color); // Logs the color property value\n * ```\n */\nexport const get = async (el: HTMLElement): Promise<CSSStyleDeclaration> => {\n  await waitForFrame();\n\n  return getComputedStyle(el, null);\n};\n","import { getCurlySVGPath, getPositionsForCurlySVGPath } from '../bezier';\nimport { direction_of_element } from '../direction-of-element';\nimport { uniqueID } from '../id';\nimport { add as addStyle } from '../styles';\n\n/**\n * Class representing a DrawSVGCurlyBracket instance.\n */\nexport class DrawSVGCurlyBracket {\n  #canvas: HTMLElement | SVGElement | null;\n  #originalPathElement: HTMLElement | SVGPathElement | null;\n  startElement: HTMLElement;\n  stopElement: HTMLElement;\n  firstPathElement: SVGPathElement;\n  secondPathElement: SVGPathElement;\n\n  /**\n   * Creates a new DrawSVGCurlyBracket instance.\n   * @param startElement - The starting element for the bracket.\n   * @param stopElement - The ending element for the bracket.\n   */\n  constructor(startElement: HTMLElement, stopElement: HTMLElement) {\n    this.#init(startElement, stopElement);\n  }\n\n  /**\n   * Initializes the DrawSVGCurlyBracket instance.\n   * @param startElement - The starting element for the bracket.\n   * @param stopElement - The ending element for the bracket.\n   * @throws Will throw an error if required elements are missing or not in the DOM.\n   */\n  #init(startElement: HTMLElement, stopElement: HTMLElement) {\n    if (!startElement || !stopElement) {\n      throw new Error('Missing inputs startElement and stopElement');\n    }\n\n    if (!document.body.contains(stopElement)) {\n      throw new Error('stopElement is not in the DOM');\n    }\n\n    if (!document.body.contains(startElement)) {\n      throw new Error('startElement is not in the DOM');\n    }\n\n    this.startElement = startElement;\n    this.stopElement = stopElement;\n\n    this.#canvas = document.getElementById('ph-speccer-svg');\n    this.#originalPathElement = document.getElementById('ph-speccer-path');\n\n    if (!this.#originalPathElement || !this.#canvas) {\n      throw new Error(\n        'Missing required SVG element to draw lines. Please see the documentation'\n      );\n    }\n\n    addStyle(this.#canvas, {\n      height: `${document.body.scrollHeight}px`\n    });\n\n    this.connect();\n  }\n\n  /**\n   * Connects and draws the curly bracket.\n   */\n  connect() {\n    this.draw(this.#originalPathElement as SVGPathElement);\n  }\n\n  /**\n   * Creates a new path element based on the provided path.\n   * @param path - The SVGPathElement to be used as the base path.\n   * @throws Will throw an error if no path is provided.\n   * @returns A new SVGPathElement.\n   */\n  #getPathElement(path: SVGPathElement) {\n    if (!path) {\n      throw new Error('No path given to #getPathElement!');\n    }\n\n    const _id = uniqueID();\n    const _path_el_id = `ph_draw_path-path-${_id}`;\n    const _new_path = path.cloneNode(false) as SVGPathElement;\n    const dataStartElID = this.startElement.getAttribute('id') || uniqueID();\n\n    this.startElement.setAttribute('id', dataStartElID);\n    _new_path.setAttribute('data-start-el', dataStartElID);\n    _new_path.setAttribute('id', _path_el_id);\n    _new_path.classList.remove('original');\n    _new_path.classList.add('speccer');\n\n    return _new_path;\n  }\n\n  /**\n   * Draws the curly bracket based on the provided path.\n   * @param path - The SVGPathElement to be used as the base path.\n   * @throws Will throw an error if no path is provided.\n   */\n  async draw(path: SVGPathElement) {\n    if (!path) {\n      throw new Error('No path given to draw!');\n    }\n\n    const _first_path_element = this.#getPathElement(path);\n    const _second_path_element = this.#getPathElement(path);\n\n    if (path.parentNode) {\n      this.firstPathElement = path.parentNode.insertBefore(\n        _first_path_element,\n        path.nextSibling\n      );\n      this.secondPathElement = path.parentNode.insertBefore(\n        _second_path_element,\n        path.nextSibling\n      );\n    } else {\n      throw new Error('No parentNode found for path');\n    }\n\n    const _direction = await direction_of_element({\n      stop: this.stopElement,\n      start: this.startElement,\n      crude: true\n    });\n    const { path1pos1, path1pos2, path2pos1, path2pos2 } =\n      getPositionsForCurlySVGPath(_direction);\n    const _first_path_d = await getCurlySVGPath(\n      this.startElement,\n      this.stopElement,\n      {\n        pos1: path1pos1,\n        pos2: path1pos2,\n        firstSet: true,\n        direction: _direction\n      }\n    );\n    const _second_path_d = await getCurlySVGPath(\n      this.startElement,\n      this.stopElement,\n      {\n        pos1: path2pos1,\n        pos2: path2pos2,\n        direction: _direction\n      }\n    );\n\n    this.firstPathElement.setAttribute('data-direction', _direction);\n    this.firstPathElement.setAttribute('data-pos1', path1pos1);\n    this.firstPathElement.setAttribute('data-pos2', path1pos2);\n    this.firstPathElement.setAttribute('d', _first_path_d); // SVG attributes\n    this.secondPathElement.setAttribute('data-direction', _direction);\n    this.secondPathElement.setAttribute('data-pos1', path2pos1);\n    this.secondPathElement.setAttribute('data-pos2', path2pos2);\n    this.secondPathElement.setAttribute('d', _second_path_d); // SVG attributes\n  }\n}\n\n// Exporting the class as a global object (if needed)\nwindow.DrawSVGCurlyBracket = DrawSVGCurlyBracket;\n","import { getPositionsForSVGPath, getSVGPath } from '../bezier';\nimport { direction_of_element } from '../direction-of-element';\nimport { uniqueID } from '../id';\nimport { add as addStyle } from '../styles';\n\n/**\n * Class representing a DrawSVGLine instance.\n */\nexport class DrawSVGLine {\n  #canvas: HTMLElement | SVGElement | null;\n  #originalPathElement: HTMLElement | SVGPathElement | null;\n  startElement: HTMLElement;\n  stopElement: HTMLElement;\n  line: SVGPathElement;\n\n  /**\n   * Creates a new DrawSVGLine instance.\n   * @param startElement - The starting element for the line.\n   * @param stopElement - The ending element for the line.\n   */\n  constructor(startElement: HTMLElement, stopElement: HTMLElement) {\n    this.#init(startElement, stopElement);\n  }\n\n  /**\n   * Initializes the DrawSVGLine instance.\n   * @param startElement - The starting element for the line.\n   * @param stopElement - The ending element for the line.\n   * @throws Will throw an error if required elements are missing or not in the DOM.\n   */\n  #init(startElement: HTMLElement, stopElement: HTMLElement) {\n    if (!startElement || !stopElement) {\n      throw new Error('Missing inputs startElement and stopElement');\n    }\n\n    if (!document.body.contains(stopElement)) {\n      throw new Error('stopElement is not in the DOM');\n    }\n\n    if (!document.body.contains(startElement)) {\n      throw new Error('startElement is not in the DOM');\n    }\n\n    this.startElement = startElement;\n    this.stopElement = stopElement;\n\n    this.#canvas = document.getElementById('ph-speccer-svg');\n    this.#originalPathElement = document.getElementById('ph-speccer-path');\n\n    if (!this.#originalPathElement || !this.#canvas) {\n      throw new Error(\n        'Missing required SVG element to draw lines. Please see the documentation'\n      );\n    }\n\n    addStyle(this.#canvas, {\n      height: `${document.body.scrollHeight}px`\n    });\n\n    this.connect();\n  }\n\n  /**\n   * Connects and draws the line.\n   */\n  connect() {\n    this.draw(this.#originalPathElement as SVGPathElement);\n  }\n\n  /**\n   * Draws the line based on the provided path.\n   * @param path - The SVGPathElement to be used as the base path.\n   * @throws Will throw an error if no path is provided.\n   */\n  async draw(path: SVGPathElement) {\n    if (!path) {\n      throw new Error('No path given to draw!');\n    }\n\n    const _id = uniqueID();\n    const _path_el_id = `ph_draw_path-path-${_id}`;\n    const _new_path = path.cloneNode(false) as SVGPathElement;\n    const dataStartElID = this.startElement.getAttribute('id') || uniqueID();\n\n    this.startElement.setAttribute('id', dataStartElID);\n\n    _new_path.setAttribute('id', _path_el_id);\n    _new_path.setAttribute('data-start-el', dataStartElID);\n    _new_path.classList.remove('original');\n    _new_path.classList.add('speccer');\n\n    if (path.parentNode) {\n      this.line = path.parentNode.insertBefore(_new_path, path.nextSibling);\n    } else {\n      throw new Error('No parentNode found for path');\n    }\n\n    const _direction = await direction_of_element({\n      start: this.startElement,\n      stop: this.stopElement,\n      crude: true\n    });\n    const { pos1, pos2 } = getPositionsForSVGPath(_direction);\n    const _d = await getSVGPath(this.startElement, this.stopElement, {\n      pos1,\n      pos2\n    });\n\n    this.line.setAttribute('data-direction', _direction);\n    this.line.setAttribute('data-pos1', pos1);\n    this.line.setAttribute('data-pos2', pos2);\n\n    this.line.setAttribute('d', _d); // SVG attributes\n  }\n}\n\n// Exporting the class as a global object (if needed)\nwindow.DrawSVGLine = DrawSVGLine;\n","/* eslint no-console:0 */\nimport {\n  ClassNamesFirstArgType,\n  ClassNamesSecondArgType\n} from '../types/interfaces/classnames';\n\nimport { isNotString } from './typeof';\n\n/**\n * Add CSS classes to an HTML element.\n *\n * @param {HTMLElement} el - The HTML element to which classes should be added.\n * @param {string} cls - The CSS classes to add, separated by spaces.\n * @param {string} [avoid='noop'] - Classes to avoid adding.\n * @returns {void}\n * @example\n * ```ts\n * // Add classes to an HTML element\n * const element = document.getElementById('example');\n * set(element, 'class1 class2');\n * ```\n */\nexport const set = (el: HTMLElement, cls: string, avoid = 'noop') => {\n  if (!el) return;\n\n  if (!cls || (cls && !cls.length)) return;\n\n  cls\n    .trim()\n    .split(' ')\n    .filter((cl) => cl !== avoid)\n    .forEach((cl) => el.classList.add(cl));\n};\n\n/**\n * Toggle CSS classes on an HTML element.\n *\n * @param {HTMLElement} el - The HTML element on which classes should be toggled.\n * @param {string} cls - The CSS classes to toggle, separated by spaces.\n * @param {string} [avoid='noop'] - Classes to avoid toggling.\n * @returns {void}\n * @example\n * ```ts\n * // Toggle classes on an HTML element\n * const element = document.getElementById('example');\n * toggle(element, 'class1 class2');\n * ```\n */\nexport const toggle = (el: HTMLElement, cls: string, avoid = 'noop') => {\n  if (!el) return;\n\n  if (!cls || (cls && !cls.length)) return;\n\n  cls\n    .trim()\n    .split(' ')\n    .filter((cl) => cl !== avoid)\n    .forEach((cl) => el.classList.toggle(cl));\n};\n\n/**\n * Remove CSS classes from an HTML element.\n *\n * @param {HTMLElement} el - The HTML element from which classes should be removed.\n * @param {string} cls - The CSS classes to remove, separated by spaces.\n * @param {string} [avoid='noop'] - Classes to avoid removing.\n * @returns {void}\n * @example\n * ```ts\n * // Remove classes from an HTML element\n * const element = document.getElementById('example');\n * remove(element, 'class1 class2');\n * ```\n */\nexport const remove = (el: HTMLElement, cls: string, avoid = 'noop') => {\n  if (!el) return;\n\n  if (!cls || (cls && !cls.length)) return;\n\n  cls\n    .trim()\n    .split(' ')\n    .filter((cl) => cl !== avoid)\n    .forEach((cl) => el.classList.remove(cl));\n};\n\n/**\n * Combines class names and optional properties object into a single string of class names.\n *\n * The `cx` function takes two parameters: `cls` and `cls_obj`.\n * The `cls` parameter can be either a string representing class names or an object with\n * properties set to `true` or `false`. The `cls_obj` parameter is an optional object with\n *  properties set to `true` or `false`, allowing for conditional inclusion of class names.\n *\n * @param {ClassNamesFirstArgType} cls - The class names as a string or an object with properties set to true or false.\n * @param {ClassNamesObjectMapInterface} cls_obj - An optional object with properties set to true or false to conditionally include class names.\n * @returns {string} - Returns a single string containing the combined class names.\n * @example\n * ```ts\n * // Generate CSS classes from a string and an object\n * const classNames = cx('class1', { class2: true, class3: false });\n * console.log(classNames); // Example output: 'class1 class2'\n * ```\n */\nexport const cx = (\n  cls: ClassNamesFirstArgType,\n  cls_obj?: ClassNamesSecondArgType\n): string => {\n  if (!cls) return '';\n\n  if (!cls_obj && isNotString(cls))\n    return Object.keys(cls)\n      .filter((classname) => cls[classname])\n      .join(' ')\n      .trim();\n\n  return `${(cls as string).trim()} ${\n    cls_obj\n      ? Object.keys(cls_obj)\n        .filter((classname) => cls_obj[classname])\n        .join(' ')\n      : ''\n  }`.trim();\n};\n","/* eslint-disable import/no-unused-modules */\n/* eslint no-console:0 */\n/**\n * Array of uppercase letters.\n *\n * @type {string[]}\n * @example\n * ```ts\n * // Access the array of uppercase letters\n * const letters = SPECCER_LITERALS;\n * console.log(letters); // Example output: ['A', 'B', 'C', ...]\n * ```\n */\nexport const SPECCER_LITERALS: string[] = [...'ABCDEFGHIJKLMNOPQRSTUVWXYZ'];\n\n/**\n * Array of HTML tags to avoid when processing.\n *\n * @type {string[]}\n * @example\n * ```ts\n * // Access the array of tags to avoid\n * const tagsToAvoid = SPECCER_TAGS_TO_AVOID;\n * console.log(tagsToAvoid); // Example output: ['TR', 'TH', 'TD', ...]\n * ```\n */\nexport const SPECCER_TAGS_TO_AVOID: string[] = [\n  'TR',\n  'TH',\n  'TD',\n  'TBODY',\n  'THEAD',\n  'TFOOT'\n];\n\n/**\n * Default value for pin space.\n *\n * @type {number}\n * @example\n * ```ts\n * // Access the default pin space value\n * const defaultPinSpace = SPECCER_DEFAULT_PIN_SPACE;\n * console.log(defaultPinSpace); // Example output: 48\n * ```\n */\nexport const SPECCER_DEFAULT_PIN_SPACE = 48;\n\n/**\n * Negative default value for pin space.\n *\n * @type {number}\n * @example\n * ```ts\n * // Access the negative default pin space value\n * const negativeDefaultPinSpace = SPECCER_DEFAULT_PIN_SPACE_NEG;\n * console.log(negativeDefaultPinSpace); // Example output: -48\n * ```\n */\nexport const SPECCER_DEFAULT_PIN_SPACE_NEG: number =\n  SPECCER_DEFAULT_PIN_SPACE * -1;\n\n/**\n * Default value for measure size.\n *\n * @type {number}\n * @example\n * ```ts\n * // Access the default measure size value\n * const defaultMeasureSize = SPECCER_DEFAULT_MEASURE_SIZE;\n * console.log(defaultMeasureSize); // Example output: 8\n * ```\n */\nexport const SPECCER_DEFAULT_MEASURE_SIZE = 8;\n\n/**\n * Negative default value for measure size.\n *\n * @type {number}\n * @example\n * ```ts\n * // Access the negative default measure size value\n * const negativeDefaultMeasureSize = SPECCER_DEFAULT_MEASURE_SIZE_NEG;\n * console.log(negativeDefaultMeasureSize); // Example output: -8\n * ```\n */\nexport const SPECCER_DEFAULT_MEASURE_SIZE_NEG: number =\n  SPECCER_DEFAULT_MEASURE_SIZE * -1;\n\n/**\n * Default line width value.\n *\n * @type {number}\n * @example\n * ```ts\n * // Access the default line width value\n * const defaultLineWidth = SPECCER_DEFAULT_LINE_WIDTH;\n * console.log(defaultLineWidth); // Example output: 1\n * ```\n */\nexport const SPECCER_DEFAULT_LINE_WIDTH = 1;\n","/* eslint no-console:0 */\nimport {\n  SpacingCSSPropertiesType,\n  TypographyCSSPropertiesType\n} from '../types/css';\n\nimport {\n  SPECCER_DEFAULT_PIN_SPACE,\n  SPECCER_DEFAULT_MEASURE_SIZE,\n  SPECCER_DEFAULT_LINE_WIDTH\n} from './constants';\n\n/**\n * Parses a string value into an integer.\n *\n * @param {string} value - The string value to parse.\n * @returns {number} - The parsed integer value.\n *\n * @example\n * ```ts\n * // Parse a string value into an integer\n * const intValue = getNumberValue(\"42\");\n * console.log(intValue); // Example output: 42\n * ```\n */\nexport const getNumberValue = (value: string): number => parseInt(value, 10);\n\n/**\n * Normalizes a string or number value to ensure it's a valid number.\n * If the value is within the range [0, 1] or [-1, 0), it's normalized to 0.\n *\n * @param {string | number} value - The value to normalize.\n * @returns {number} - The normalized number value.\n *\n * @example\n * ```ts\n * // Normalize a value to ensure it's a valid number\n * const normalizedValue = normalizeNumberValue(\"0.5\");\n * console.log(normalizedValue); // Example output: 0.5\n * ```\n */\nexport const normalizeNumberValue = (value: string | number): number => {\n  const _value = parseFloat(value + '');\n\n  return (_value >= 0 && _value < 1) || (_value <= 0 && _value > -1)\n    ? 0\n    : _value;\n};\n\n/**\n * Converts a CSS property name with \"Top\", \"Right\", \"Bottom\", or \"Left\" into a class name.\n *\n * @param {string} property - The CSS property name.\n * @returns {string} - The corresponding class name.\n *\n * @example\n * ```ts\n * // Convert a CSS property name to a class name\n * const className = getClassNameFromCSSProperty(\"marginTop\");\n * console.log(className); // Example output: \"margin top\"\n * ```\n */\nexport const getClassNameFromCSSProperty = (property: string): string => {\n  if (property.includes('Top')) {\n    return property.replace('Top', ' top');\n  } else if (property.includes('Right')) {\n    return property.replace('Right', ' right');\n  } else if (property.includes('Bottom')) {\n    return property.replace('Bottom', ' bottom');\n  } else if (property.includes('Left')) {\n    return property.replace('Left', ' left');\n  }\n\n  return '';\n};\n\n/**\n * Extracts spacing-related CSS properties from a style object.\n *\n * @param {SpacingCSSPropertiesType} style - The style object.\n * @returns {SpacingCSSPropertiesType} - The extracted spacing-related properties.\n *\n * @example\n * ```ts\n * // Extract spacing-related properties from a style object\n * const spacing = getSpacing({\n *   marginTop: \"10px\",\n *   marginLeft: \"20px\",\n * });\n * console.log(spacing); // Example output: { marginTop: \"10px\", marginLeft: \"20px\" }\n * ```\n */\nexport const getSpacing = (\n  style: SpacingCSSPropertiesType\n): SpacingCSSPropertiesType => {\n  const {\n    marginTop,\n    marginBottom,\n    marginLeft,\n    marginRight,\n    paddingTop,\n    paddingBottom,\n    paddingLeft,\n    paddingRight\n  } = style;\n\n  return {\n    marginTop,\n    marginBottom,\n    marginLeft,\n    marginRight,\n    paddingTop,\n    paddingBottom,\n    paddingLeft,\n    paddingRight\n  };\n};\n\n/**\n * Extracts typography-related CSS properties from a style object.\n *\n * @param {TypographyCSSPropertiesType} style - The style object.\n * @returns {TypographyCSSPropertiesType} - The extracted typography-related properties.\n *\n * @example\n * ```ts\n * // Extract typography-related properties from a style object\n * const typography = getTypography({\n *   fontSize: \"16px\",\n *   fontWeight: \"bold\",\n * });\n * console.log(typography); // Example output: { fontSize: \"16px\", fontWeight: \"bold\" }\n * ```\n */\nexport const getTypography = (\n  style: TypographyCSSPropertiesType\n): TypographyCSSPropertiesType => {\n  const {\n    lineHeight,\n    letterSpacing,\n    fontFamily,\n    fontSize,\n    fontStyle,\n    fontVariationSettings,\n    fontWeight\n  } = style;\n\n  return {\n    lineHeight,\n    letterSpacing,\n    fontFamily,\n    fontSize,\n    fontStyle,\n    fontVariationSettings,\n    fontWeight\n  };\n};\n\n/**\n * Retrieves the value of a custom CSS property \"--ph-speccer-pin-space\" from an element.\n *\n * @param {HTMLElement} el - The HTML element.\n * @returns {number} - The parsed value of the CSS property or a default value.\n *\n * @example\n * ```ts\n * // Get the value of a custom CSS property from an element\n * const value = pinSpace(document.body);\n * console.log(value); // Example output: 10\n * ```\n */\nexport const pinSpace = (el: HTMLElement): number =>\n  getNumberValue(\n    getComputedStyle(el).getPropertyValue('--ph-speccer-pin-space')\n  ) || SPECCER_DEFAULT_PIN_SPACE;\n\n/**\n * Retrieves the value of a custom CSS property \"--ph-speccer-measure-size\" from an element.\n *\n * @param {HTMLElement} el - The HTML element.\n * @returns {number} - The parsed value of the CSS property or a default value.\n *\n * @example\n * ```ts\n * // Get the value of a custom CSS property from an element\n * const value = measureSize(document.body);\n * console.log(value); // Example output: 20\n * ```\n */\nexport const measureSize = (el: HTMLElement): number =>\n  getNumberValue(\n    getComputedStyle(el).getPropertyValue('--ph-speccer-measure-size')\n  ) || SPECCER_DEFAULT_MEASURE_SIZE;\n\n/**\n * Retrieves the value of a custom CSS property \"--ph-speccer-line-width\" from an element.\n *\n * @param {HTMLElement} el - The HTML element.\n * @returns {number} - The parsed value of the CSS property or a default value.\n *\n * @example\n * ```ts\n * // Get the value of a custom CSS property from an element\n * const value = lineWidth(document.body);\n * console.log(value); // Example output: 1.5\n * ```\n */\nexport const lineWidth = (el: HTMLElement): number =>\n  getNumberValue(\n    getComputedStyle(el).getPropertyValue('--ph-speccer-line-width')\n  ) || SPECCER_DEFAULT_LINE_WIDTH;\n","import { GetRecPropertiesInterface } from '../types/interfaces/position';\nimport { PositionPropertiesType, PositionInputType } from '../types/position';\n\nimport { waitForFrame } from './wait';\n\n/**\n * Calculates the horizontal center of two elements.\n *\n * @param {number} modifier - A modifier value.\n * @param {DOMRect} startRect - The starting element's rectangle.\n * @param {DOMRect} targetRect - The target element's rectangle.\n * @returns {number} - The horizontal center position.\n *\n * @example\n * ```ts\n * // Calculate the horizontal center of two elements\n * const center = get_horizontal_center_of_els(0, startRect, targetRect);\n * ```\n */\nexport const get_horizontal_center_of_els = (\n  modifier: number,\n  startRect: DOMRect,\n  targetRect: DOMRect\n): number => modifier - startRect.width / 2 + targetRect.width / 2;\n\n/**\n * Calculates the vertical center of two elements.\n *\n * @param {number} modifier - A modifier value.\n * @param {DOMRect} startRect - The starting element's rectangle.\n * @param {DOMRect} targetRect - The target element's rectangle.\n * @returns {number} - The vertical center position.\n *\n * @example\n * ```ts\n * // Calculate the vertical center of two elements\n * const center = get_vertical_center_of_els(0, startRect, targetRect);\n * ```\n */\nexport const get_vertical_center_of_els = (\n  modifier: number,\n  startRect: DOMRect,\n  targetRect: DOMRect\n): number => modifier - startRect.height / 2 + targetRect.height / 2;\n\n/**\n * Gets the offset properties of an HTML element.\n *\n * @param {HTMLElement} targetEl - The target HTML element.\n * @returns {Promise<PositionPropertiesType>} - A promise that resolves to the offset properties.\n *\n * @example\n * ```ts\n * // Get the offset properties of an element\n * const offsetProps = await offset(targetElement);\n * ```\n */\nexport const offset = async (\n  targetEl: HTMLElement\n): Promise<PositionPropertiesType> => {\n  await waitForFrame();\n\n  const _target_rect = targetEl.getBoundingClientRect();\n  const _el_offset_top = _target_rect.top + window.scrollY;\n  const _el_offset_left = _target_rect.left + window.scrollX;\n\n  return {\n    height: _target_rect.height,\n    width: _target_rect.width,\n    top: _el_offset_top,\n    left: _el_offset_left\n  };\n};\n\n/**\n * Gets the offset properties of an HTML element with its center aligned to another element.\n *\n * @param {HTMLElement} sourceEl - The source HTML element.\n * @param {HTMLElement} targetEl - The target HTML element.\n * @returns {Promise<PositionPropertiesType>} - A promise that resolves to the offset properties.\n *\n * @example\n * ```ts\n * // Get the offset properties of an element with its center aligned to another element\n * const offsetProps = await offsetWithCenter(sourceElement, targetElement);\n * ```\n */\nexport const offsetWithCenter = async (\n  sourceEl: HTMLElement,\n  targetEl: HTMLElement\n): Promise<PositionPropertiesType> => {\n  await waitForFrame();\n\n  const _source_rect = sourceEl.getBoundingClientRect();\n  const _target_rect = targetEl.getBoundingClientRect();\n  const _el_offset_top = _target_rect.top + window.scrollY;\n  const _el_offset_left = _target_rect.left + window.scrollX;\n\n  return {\n    height: _target_rect.height,\n    width: _target_rect.width,\n    top: get_vertical_center_of_els(_el_offset_top, _source_rect, _target_rect),\n    left: get_horizontal_center_of_els(\n      _el_offset_left,\n      _source_rect,\n      _target_rect\n    )\n  };\n};\n\n/**\n * Gets various positioning properties between two HTML elements.\n *\n * @param {HTMLElement} sourceEl - The source HTML element.\n * @param {HTMLElement} targetEl - The target HTML element.\n * @returns {Promise<GetRecPropertiesInterface>} - A promise that resolves to an object with positioning functions.\n *\n * @example\n * ```ts\n * // Get positioning properties between two elements\n * const recProps = await getRec(sourceElement, targetElement);\n *\n * // Get the absolute position properties\n * const absoluteProps = recProps.absolute();\n *\n * // Get the position properties with the source element above the target element\n * const aboveProps = recProps.toTop();\n * ```\n */\nexport const getRec = async (\n  sourceEl: HTMLElement,\n  targetEl: HTMLElement\n): Promise<GetRecPropertiesInterface> => {\n  await waitForFrame();\n\n  const _source_rect = sourceEl.getBoundingClientRect();\n  const _target_offset = await offset(targetEl);\n  const _target_offset_center = await offsetWithCenter(sourceEl, targetEl);\n  const _target_height = _target_offset.height;\n  const _target_width = _target_offset.width;\n  const _source_height = _source_rect.height;\n  const _source_width = _source_rect.width;\n\n  return {\n    absolute: (): PositionPropertiesType => ({\n      top: _target_offset.top,\n      left: _target_offset.left,\n      height: _target_height,\n      width: _target_width\n    }),\n    toTop: ({\n      center = false,\n      sourceHeight = _source_height,\n      modifier = 0\n    }: PositionInputType = {}): PositionPropertiesType => ({\n      top: _target_offset.top + sourceHeight + modifier,\n      left: center ? _target_offset_center.left : _target_offset.left,\n      height: _target_height,\n      width: _target_width\n    }),\n\n    fromTop: ({\n      center = false,\n      sourceHeight = _source_height,\n      modifier = 0\n    }: PositionInputType = {}): PositionPropertiesType => ({\n      top: _target_offset.top - sourceHeight - modifier,\n      left: center ? _target_offset_center.left : _target_offset.left,\n      height: _target_height,\n      width: _target_width\n    }),\n\n    toBottom: ({\n      center = false,\n      sourceHeight = _source_height,\n      targetHeight = _target_height,\n      modifier = 0\n    }: PositionInputType = {}): PositionPropertiesType => ({\n      top: _target_offset.top + targetHeight - (sourceHeight + modifier),\n      left: center ? _target_offset_center.left : _target_offset.left,\n      height: _target_height,\n      width: _target_width\n    }),\n    fromBottom: ({\n      center = false,\n      targetHeight = _target_height,\n      modifier = 0\n    }: PositionInputType = {}): PositionPropertiesType => ({\n      top: _target_offset.top + targetHeight + modifier,\n      left: center ? _target_offset_center.left : _target_offset.left,\n      height: _target_height,\n      width: _target_width\n    }),\n\n    toLeft: ({\n      center = false,\n      sourceWidth = _source_width,\n      modifier = 0\n    }: PositionInputType = {}): PositionPropertiesType => ({\n      top: center ? _target_offset_center.top : _target_offset.top,\n      left: _target_offset.left + sourceWidth + modifier,\n      height: _target_height,\n      width: _target_width\n    }),\n\n    fromLeft: ({\n      center = false,\n      sourceWidth = _source_width,\n      modifier = 0\n    }: PositionInputType = {}): PositionPropertiesType => ({\n      top: center ? _target_offset_center.top : _target_offset.top,\n      left: _target_offset.left - sourceWidth - modifier,\n      height: _target_height,\n      width: _target_width\n    }),\n\n    toRight: ({\n      center = false,\n      sourceWidth = _source_width,\n      targetWidth = _target_width,\n      modifier = 0\n    }: PositionInputType = {}): PositionPropertiesType => ({\n      top: center ? _target_offset_center.top : _target_offset.top,\n      left: _target_offset.left + targetWidth - (sourceWidth + modifier),\n      height: _target_height,\n      width: _target_width\n    }),\n\n    fromRight: ({\n      center = false,\n      targetWidth = _target_width,\n      modifier = 0\n    }: PositionInputType = {}): PositionPropertiesType => ({\n      top: center ? _target_offset_center.top : _target_offset.top,\n      left: _target_offset.left + targetWidth + modifier,\n      height: _target_height,\n      width: _target_width\n    })\n  };\n};\n","import { DissectStylesOptionsType } from '../../../types/bezier';\nimport {\n  isBottomArea,\n  isEncloseArea,\n  isFullArea,\n  isLeftArea,\n  isRightArea\n} from '../../../utils/area';\nimport { pinSpace, measureSize } from '../../../utils/css';\nimport { getRec } from '../../../utils/position';\n\n/**\n * Get styles for dissected elements based on the specified area and options.\n *\n * @param {string} area - The area description.\n * @param {HTMLElement} targetEl - The target element.\n * @param {HTMLElement} dissectionEl - The dissection element.\n * @param {DissectStylesOptionsType} options - Optional styles options.\n * @returns {Promise<{ left: string; top: string; height?: string; width?: string }>} - The computed styles.\n *\n * @example\n * ```ts\n * const area = 'top-left';\n * const targetElement = document.getElementById('target');\n * const dissectionElement = document.getElementById('dissection');\n * const options = { isCurly: true };\n * const styles = await styles(area, targetElement, dissectionElement, options);\n * console.log(styles);\n * ```\n */\nexport const styles = async (\n  area: string,\n  targetEl: HTMLElement,\n  dissectionEl: HTMLElement,\n  options?: DissectStylesOptionsType\n): Promise<{ left: string; top: string; height?: string; width?: string }> => {\n  const { isCurly = false } = options || {};\n  const SPECCER_PIN_SPACE = pinSpace(dissectionEl);\n  const SPECCER_MEASURE_SIZE = measureSize(dissectionEl);\n  const _positional_styles = await getRec(dissectionEl, targetEl);\n\n  if (isEncloseArea(area)) {\n    const { left, top, height, width } = _positional_styles.absolute();\n\n    return {\n      left: `${left}px`,\n      top: `${top}px`,\n      height: `${height}px`,\n      width: `${width}px`\n    };\n  }\n\n  if (isLeftArea(area)) {\n    if (isFullArea(area) && !isCurly) {\n      const { left, top, height } = _positional_styles.fromLeft({\n        sourceWidth: SPECCER_MEASURE_SIZE\n      });\n\n      return {\n        left: `${left}px`,\n        top: `${top}px`,\n        height: `${height}px`\n      };\n    } else {\n      const { left, top } = _positional_styles.fromLeft({\n        center: true,\n        modifier: isCurly ? SPECCER_PIN_SPACE / 1.5 : SPECCER_PIN_SPACE\n      });\n\n      return {\n        left: `${left}px`,\n        top: `${top}px`\n      };\n    }\n  } else if (isRightArea(area)) {\n    if (isFullArea(area) && !isCurly) {\n      const { left, top, height } = _positional_styles.fromRight({\n        center: false\n      });\n\n      return {\n        left: `${left}px`,\n        top: `${top}px`,\n        height: `${height}px`\n      };\n    } else {\n      const { left, top } = _positional_styles.fromRight({\n        center: true,\n        modifier: isCurly ? SPECCER_PIN_SPACE / 1.5 : SPECCER_PIN_SPACE\n      });\n\n      return {\n        left: `${left}px`,\n        top: `${top}px`\n      };\n    }\n  } else if (isBottomArea(area)) {\n    if (isFullArea(area) && !isCurly) {\n      const { left, top, width } = _positional_styles.fromBottom({\n        center: false\n      });\n\n      return {\n        left: `${left}px`,\n        top: `${top}px`,\n        width: `${width}px`\n      };\n    } else {\n      const { left, top } = _positional_styles.fromBottom({\n        center: true,\n        modifier: isCurly ? SPECCER_PIN_SPACE / 1.5 : SPECCER_PIN_SPACE\n      });\n\n      return {\n        left: `${left}px`,\n        top: `${top}px`\n      };\n    }\n  } else {\n    if (isFullArea(area) && !isCurly) {\n      const { left, top, width } = _positional_styles.fromTop({\n        center: false\n      });\n\n      return {\n        left: `${left}px`,\n        top: `${top}px`,\n        width: `${width}px`\n      };\n    } else {\n      const { left, top } = _positional_styles.fromTop({\n        center: true,\n        modifier: isCurly ? SPECCER_PIN_SPACE / 1.5 : SPECCER_PIN_SPACE\n      });\n\n      return {\n        left: `${left}px`,\n        top: `${top}px`\n      };\n    }\n  }\n};\n","/* eslint no-console:0 */\nimport { DissectAreaEnum } from '../../types/enums/area';\nimport { isCurly, isEncloseArea, isFullArea, useSVG } from '../../utils/area';\nimport { DrawSVGCurlyBracket } from '../../utils/classes/DrawSVGCurlyBracket';\nimport { DrawSVGLine } from '../../utils/classes/DrawSVGLine';\nimport { set as setClassNames, cx } from '../../utils/classnames';\nimport { SPECCER_LITERALS } from '../../utils/constants';\nimport { add } from '../../utils/styles';\n\nimport { styles } from './utils/styles';\n\n/**\n * Create a dissected element with optional text content, area description, and element type.\n *\n * @param {string} textContent - The text content to add to the element.\n * @param {string} area - The area description for styling.\n * @param {string} n - The element type.\n * @returns {HTMLElement} - The created dissected element.\n *\n * @example\n * ```ts\n * const dissectedElement = create('A', 'outline top', 'div');\n * document.body.appendChild(dissectedElement);\n * ```\n */\nexport const create = (\n  textContent = '',\n  area: string,\n  n = 'span'\n): HTMLElement => {\n  const _el = document.createElement(n);\n  const _text_node = document.createTextNode(textContent);\n  const _extra_class_names = {};\n\n  if (area !== null && area !== '') _extra_class_names[area] = true;\n\n  if (\n    (!isFullArea(area) && !isEncloseArea(area)) ||\n    (isFullArea(area) && isCurly(area))\n  )\n    _el.appendChild(_text_node);\n  else if (isFullArea(area) || isEncloseArea(area))\n    _el.setAttribute('data-dissection-counter', textContent);\n\n  const _class_names = cx('ph-speccer speccer dissection', _extra_class_names);\n\n  setClassNames(_el, _class_names);\n\n  return _el;\n};\n\n/**\n * Create dissected elements based on the section element and its data-anatomy attributes.\n *\n * @param {HTMLElement} sectionEl - The section element containing dissected elements.\n * @returns {Promise<void>} - A promise that resolves after creating dissected elements.\n *\n * @example\n * ```ts\n * const sectionElement = document.getElementById('section');\n * element(sectionElement);\n * ```\n */\nexport const element = async (sectionEl: HTMLElement): Promise<void> => {\n  if (!sectionEl) return;\n\n  const _dissection_els = sectionEl.querySelectorAll('[data-anatomy]');\n\n  if (_dissection_els) {\n    let _index_to_use = 0;\n\n    for (const [targetIndex, targetEl] of _dissection_els.entries()) {\n      if (!targetEl) continue;\n\n      const _areas_string: string = targetEl.getAttribute('data-anatomy') || '';\n\n      if (\n        !_areas_string ||\n        _areas_string === '' ||\n        !_areas_string.includes(DissectAreaEnum.Outline)\n      )\n        continue;\n\n      /**\n       * If we're running out of literals to use,\n       * make a new one with uppercase and lowercase pairs\n       */\n      let _literal_to_use = SPECCER_LITERALS[targetIndex];\n\n      if (!_literal_to_use) {\n        _literal_to_use = `${SPECCER_LITERALS[_index_to_use]}${SPECCER_LITERALS[\n          _index_to_use\n        ].toLowerCase()}`;\n        _index_to_use++;\n      }\n\n      const _dissection_el = create(_literal_to_use, _areas_string);\n\n      document.body.appendChild(_dissection_el);\n\n      const _dissection_styles = await styles(\n        _areas_string,\n        targetEl as HTMLElement,\n        _dissection_el,\n        {\n          isCurly: isCurly(_areas_string)\n        }\n      );\n\n      await add(_dissection_el, _dissection_styles);\n\n      if (useSVG(_areas_string) && !isCurly(_areas_string))\n        new DrawSVGLine(targetEl as HTMLElement, _dissection_el);\n      else if (isCurly(_areas_string))\n        new DrawSVGCurlyBracket(targetEl as HTMLElement, _dissection_el);\n    }\n  }\n};\n","/* eslint no-console:0 */\nimport {\n  isBottomArea,\n  isHeightArea,\n  isRightArea,\n  isWidthArea\n} from '../../utils/area';\nimport { set as setClassNames } from '../../utils/classnames';\nimport { SPECCER_DEFAULT_MEASURE_SIZE_NEG } from '../../utils/constants';\nimport { getRec } from '../../utils/position';\nimport { get as getStyles, add as addStyles } from '../../utils/styles';\nimport { waitForFrame } from '../../utils/wait';\n\n/**\n * Create a measurement element with optional text, area, and element type.\n *\n * @param {string | number} text - The text to display on the element.\n * @param {string | null} area - The area to specify with CSS class.\n * @param {string} tag - The element type.\n * @returns {HTMLElement} - The created measurement element.\n *\n * @example\n * ```ts\n * const measurement = create(100, 'width bottom', 'div');\n * document.body.appendChild(measurement);\n * ```\n */\nexport const create = (\n  text: string | number = '',\n  area: string | null = '',\n  tag = 'span'\n): HTMLElement => {\n  const _el = document.createElement(tag);\n\n  _el.setAttribute('title', `${text}px`);\n  _el.setAttribute('data-measure', `${parseInt(`${text}`, 10)}px`);\n\n  setClassNames(_el, `ph-speccer speccer measure ${area}`);\n\n  return _el;\n};\n\n/**\n * Create a measurement element and add it to the body with styles matching a specified target element.\n *\n * @param {HTMLElement} targetEl - The target element to match styles with.\n * @returns {Promise<void>} - A promise that resolves after creating and styling the measurement element.\n *\n * @example\n * ```ts\n * const targetElement = document.getElementById('target');\n * element(targetElement);\n * ```\n */\nexport const element = async (targetEl: HTMLElement): Promise<void> => {\n  if (!targetEl) return;\n\n  const _areas_string: string | null = targetEl.getAttribute(\n    'data-speccer-measure'\n  );\n\n  if (_areas_string === '' || !_areas_string) return;\n\n  const _target_styles = await getStyles(targetEl);\n\n  if (\n    _target_styles.display === 'none' ||\n    _target_styles.opacity === '0' ||\n    _target_styles.visibility === 'hidden'\n  )\n    return;\n\n  await waitForFrame();\n\n  const _target_rect = targetEl.getBoundingClientRect();\n\n  if (isWidthArea(_areas_string)) {\n    if (isBottomArea(_areas_string)) {\n      const _measure_el = create(_target_rect.width, _areas_string);\n\n      document.body.appendChild(_measure_el);\n\n      const _positional_styles = await getRec(_measure_el, targetEl);\n      const { left, top, width } = _positional_styles.fromBottom({\n        center: false\n      });\n\n      await addStyles(_measure_el, {\n        left: `${left}px`,\n        top: `${top}px`,\n        width: `${width}px`\n      });\n    } else {\n      const _measure_el = create(_target_rect.width, _areas_string);\n\n      document.body.appendChild(_measure_el);\n\n      const _positional_styles = await getRec(_measure_el, targetEl);\n      const { left, top, width } = _positional_styles.fromTop({\n        center: false,\n        modifier: SPECCER_DEFAULT_MEASURE_SIZE_NEG\n      });\n\n      await addStyles(_measure_el, {\n        left: `${left}px`,\n        top: `${top}px`,\n        width: `${width}px`\n      });\n    }\n  } else if (isHeightArea(_areas_string)) {\n    if (isRightArea(_areas_string)) {\n      const _measure_el = create(_target_rect.height, _areas_string);\n\n      document.body.appendChild(_measure_el);\n\n      const _positional_styles = await getRec(_measure_el, targetEl);\n      const { left, top, height } = _positional_styles.fromRight({\n        center: false\n      });\n\n      await addStyles(_measure_el, {\n        left: `${left}px`,\n        top: `${top}px`,\n        height: `${height}px`\n      });\n    } else {\n      const _measure_el = create(_target_rect.height, _areas_string);\n\n      document.body.appendChild(_measure_el);\n\n      const _positional_styles = await getRec(_measure_el, targetEl);\n      const { left, top, height } = _positional_styles.fromLeft({\n        center: false,\n        modifier: SPECCER_DEFAULT_MEASURE_SIZE_NEG\n      });\n\n      await addStyles(_measure_el, {\n        left: `${left}px`,\n        top: `${top}px`,\n        height: `${height}px`\n      });\n    }\n  }\n};\n","import { offset } from '../../../utils/position';\nimport { add as addStyles } from '../../../utils/styles';\nimport { waitForFrame } from '../../../utils/wait';\n\n/**\n * Set the position and dimensions of a spacing element relative to a target element.\n *\n * @param {string} property - The CSS property to set (e.g., 'marginTop', 'marginLeft', etc.).\n * @param {number} value - The value of the CSS property.\n * @param {HTMLElement} spacingEl - The spacing element.\n * @param {HTMLElement} targetEl - The target element.\n * @returns {Promise<void>} - A promise that resolves after setting the position and dimensions.\n *\n * @example\n * ```ts\n * const spacingElement = document.getElementById('spacing');\n * const targetElement = document.getElementById('target');\n * position('marginTop', 20, spacingElement, targetElement);\n * ```\n */\nexport const position = async (\n  property: string,\n  value: number,\n  spacingEl: HTMLElement,\n  targetEl: HTMLElement\n): Promise<void> => {\n  await waitForFrame();\n\n  const _target_rect = targetEl.getBoundingClientRect();\n  const _target_offset = await offset(targetEl);\n\n  if (property === 'marginTop')\n    addStyles(spacingEl, {\n      height: `${value}px`,\n      width: _target_rect.width + 'px',\n      left: _target_offset.left + 'px',\n      top: _target_offset.top - value + 'px'\n    });\n\n  if (property === 'marginRight')\n    addStyles(spacingEl, {\n      height: _target_rect.height + 'px',\n      width: `${value}px`,\n      left: _target_offset.left + parseInt(_target_rect.width + '', 10) + 'px',\n      top: _target_offset.top + 'px'\n    });\n\n  if (property === 'marginBottom')\n    addStyles(spacingEl, {\n      height: `${value}px`,\n      width: _target_rect.width + 'px',\n      left: _target_offset.left + 'px',\n      top: _target_offset.top + parseInt(_target_rect.height + '', 10) + 'px'\n    });\n\n  if (property === 'marginLeft')\n    addStyles(spacingEl, {\n      height: _target_rect.height + 'px',\n      width: `${value}px`,\n      left: _target_offset.left - value + 'px',\n      top: _target_offset.top + 'px'\n    });\n\n  if (property === 'paddingTop')\n    addStyles(spacingEl, {\n      height: `${value}px`,\n      width: _target_rect.width + 'px',\n      left: _target_offset.left + 'px',\n      top: _target_offset.top + 'px'\n    });\n\n  if (property === 'paddingBottom')\n    addStyles(spacingEl, {\n      height: `${value}px`,\n      width: _target_rect.width + 'px',\n      left: _target_offset.left + 'px',\n      top:\n        _target_offset.top +\n        (parseInt(_target_rect.height + '', 10) - value) +\n        'px'\n    });\n\n  if (property === 'paddingRight')\n    addStyles(spacingEl, {\n      height: _target_rect.height + 'px',\n      width: `${value}px`,\n      left:\n        _target_offset.left +\n        (parseInt(_target_rect.width + '', 10) - value) +\n        'px',\n      top: _target_offset.top + 'px'\n    });\n\n  if (property === 'paddingLeft')\n    addStyles(spacingEl, {\n      height: _target_rect.height + 'px',\n      width: `${value}px`,\n      left: _target_offset.left + 'px',\n      top: _target_offset.top + 'px'\n    });\n};\n","/* eslint no-console:0 */\nimport { set as setClassNames } from '../../utils/classnames';\nimport {\n  getSpacing,\n  getClassNameFromCSSProperty,\n  getNumberValue\n} from '../../utils/css';\nimport { get as getStyles } from '../../utils/styles';\n\nimport { position } from './utils/position';\n\n/**\n * Create a spacing element with optional text content.\n *\n * @param {string | number} text - The optional text content for the spacing element.\n * @param {string} tag - The HTML tag for the element (default is 'span').\n * @returns {HTMLElement} - The created spacing element.\n *\n * @example\n * ```ts\n * const spacingElement = create(20, 'div');\n * document.body.appendChild(spacingElement);\n * ```\n */\nexport const create = (\n  text: string | number = '',\n  tag = 'span'\n): HTMLElement => {\n  const _el = document.createElement(tag);\n  const _text_content = document.createTextNode(`${text}`);\n\n  _el.appendChild(_text_content);\n  _el.setAttribute('title', `${text}px`);\n  setClassNames(_el, 'ph-speccer speccer spacing');\n\n  return _el;\n};\n\n/**\n * Create and position spacing elements based on the target element's computed spacing styles.\n *\n * @param {HTMLElement} targetEl - The target element to create spacing elements for.\n * @returns {Promise<void>} - A promise that resolves after creating and positioning the spacing elements.\n *\n * @example\n * ```ts\n * const targetElement = document.getElementById('target');\n * element(targetElement);\n * ```\n */\nexport const element = async (targetEl: HTMLElement): Promise<void> => {\n  if (!targetEl) return;\n\n  const _target_styles = await getStyles(targetEl);\n\n  if (\n    _target_styles.display === 'none' ||\n    _target_styles.opacity === '0' ||\n    _target_styles.visibility === 'hidden'\n  )\n    return;\n\n  const _target_spacing_styles = getSpacing(_target_styles);\n  const _target_pruned_spacing_styles = Object.keys(\n    _target_spacing_styles\n  ).filter((property) => {\n    const _value = _target_spacing_styles[property];\n\n    return _value !== '0px';\n  });\n\n  if (!_target_pruned_spacing_styles.length) return;\n\n  for (const property of _target_pruned_spacing_styles) {\n    const _value = getNumberValue(_target_spacing_styles[property]);\n    const _speccer_el = create(_value);\n    const _class_name = getClassNameFromCSSProperty(property);\n\n    setClassNames(_speccer_el, _class_name);\n    document.body.appendChild(_speccer_el);\n\n    targetEl.classList.add('is-specced');\n    await position(property, _value, _speccer_el, targetEl);\n  }\n};\n","import { SpeccerFunctionType } from '../types/speccer';\n\nimport debounce from './debounce';\n\n/**\n * Attaches a debounced event listener to the window's resize event that triggers the provided function.\n *\n * @param {SpeccerFunctionType} speccer - The function to trigger when the window is resized.\n *\n * @example\n * ```ts\n * // Define a function to be triggered on window resize\n * const mySpeccer = () => {\n *   // Your logic here\n *   console.log('Window resized');\n * };\n *\n * // Activate the debounced event listener\n * activate(mySpeccer);\n * ```\n */\nexport const activate = (speccer: SpeccerFunctionType): void => {\n  /**\n   * The debounced event listener function.\n   * @type {Function}\n   */\n  const speccerEventFunc = () =>\n    debounce(() => {\n      speccer();\n    }, 300);\n\n  // Remove any existing resize event listeners to prevent duplicates\n  window.removeEventListener('resize', speccerEventFunc);\n\n  // Add the debounced resize event listener\n  window.addEventListener('resize', speccerEventFunc);\n};\n","/* eslint @typescript-eslint/no-explicit-any: [\"error\", { \"fixToUnknown\": true }] */\nimport { DebounceAnyFunctionType } from '../types/debounce';\n\n/**\n * Creates a debounced version of a function that delays its execution until after a specified waiting time has elapsed since the last time the debounced function was invoked.\n *\n * @param {DebounceAnyFunctionType} func - The function to debounce.\n * @param {number} wait - The number of milliseconds to wait before invoking the function after the last call.\n * @param {boolean} [immediate=false] - If `true`, the function is invoked immediately after the first call.\n * @returns {DebounceAnyFunctionType} - The debounced function.\n *\n * @example\n * ```ts\n * // Create a debounced function\n * const debouncedFn = debounce((value) => {\n *   console.log(value);\n * }, 500);\n *\n * // Call the debounced function\n * debouncedFn('Hello'); // This will not trigger immediate execution\n * debouncedFn('World'); // This will trigger immediate execution\n * ```\n */\nconst debounce = (\n  func: DebounceAnyFunctionType,\n  wait: number,\n  immediate = false\n): DebounceAnyFunctionType => {\n  let timeout: null | ReturnType<typeof setTimeout>;\n\n  return function (context: unknown, ...args: unknown[]): void {\n    const later = function (): void {\n      timeout = null;\n\n      if (!immediate) func.apply(context, args);\n    };\n    const callNow = immediate && !timeout;\n\n    if (timeout) clearTimeout(timeout);\n\n    timeout = setTimeout(later, wait);\n\n    if (callNow) func.apply(context, args);\n  };\n};\n\nexport default debounce;\n","/* eslint no-console:0 */\n\nimport { element as dissectElement } from '../features/dissect';\nimport { element as measureElement } from '../features/measure';\nimport { element as specElement } from '../features/spacing';\nimport { SpeccerFunctionType } from '../types/speccer';\nimport { activate as resizeActivate } from '../utils/resize';\n\n/**\n * A function to initialize speccer when the DOM is ready.\n *\n * @param {SpeccerFunctionType} speccer - The speccer function to execute.\n *\n * @example\n * ```ts\n * // Usage example:\n * // dom(mySpeccer);\n * ```\n */\nexport const dom = (speccer: SpeccerFunctionType): void => {\n  if (document.readyState === 'loading')\n    document.addEventListener('DOMContentLoaded', () => {\n      speccer();\n    });\n  // `DOMContentLoaded` already fired\n  else speccer();\n};\n\n/**\n * A function to initialize lazy speccer functionality.\n *\n * @example\n * ```ts\n * // Usage example:\n * // lazy();\n * ```\n */\nexport const lazy = (): void => {\n  const _spec_observer = new IntersectionObserver((els, observer) => {\n    for (const el of els) {\n      if (el.intersectionRatio > 0) {\n        specElement(el.target as HTMLElement);\n        observer.unobserve(el.target);\n      }\n    }\n  });\n\n  for (const el of document.querySelectorAll(\n    '[data-speccer],[data-speccer] *:not(td):not(tr):not(th):not(tfoot):not(thead):not(tbody)'\n  )) {\n    _spec_observer.observe(el);\n  }\n\n  const _measure_observer = new IntersectionObserver((els, observer) => {\n    for (const el of els) {\n      if (el.intersectionRatio > 0) {\n        measureElement(el.target as HTMLElement);\n        observer.unobserve(el.target);\n      }\n    }\n  });\n\n  for (const el of document.querySelectorAll('[data-speccer-measure]')) {\n    _measure_observer.observe(el);\n  }\n\n  const _dissect_observer = new IntersectionObserver(async (els, observer) => {\n    for (const el of els) {\n      if (el.intersectionRatio > 0) {\n        await dissectElement(el.target as HTMLElement);\n        observer.unobserve(el.target);\n      }\n    }\n  });\n\n  for (const el of document.querySelectorAll('[data-anatomy-section]')) {\n    _dissect_observer.observe(el);\n  }\n};\n\n/**\n * A function to manually activate speccer.\n *\n * @param {SpeccerFunctionType} speccer - The speccer function to execute.\n *\n * @example\n * ```ts\n * // Usage example:\n * // manual(mySpeccer);\n * ```\n */\nexport const manual = (speccer: SpeccerFunctionType): void => {\n  window.speccer = speccer;\n};\n\n/**\n * A function to activate speccer based on script attributes.\n *\n * @param {SpeccerFunctionType} speccer - The speccer function to execute.\n *\n * @example\n * ```ts\n * // Usage example:\n * // activate(mySpeccer);\n * ```\n */\nexport const activate = (speccer: SpeccerFunctionType): void => {\n  const _script = document.currentScript;\n\n  if (_script) {\n    const _speccer_script_src = _script.getAttribute('src');\n\n    if (\n      _speccer_script_src &&\n      (_speccer_script_src.includes('speccer.js') ||\n        // for codepen\n        _speccer_script_src.includes('JaXpOK.js'))\n    ) {\n      if (_script.hasAttribute('data-manual')) manual(speccer);\n      else if (_script.hasAttribute('data-instant')) speccer();\n      else if (_script.hasAttribute('data-dom')) dom(speccer);\n      else if (_script.hasAttribute('data-lazy')) lazy();\n      else dom(speccer);\n\n      if (\n        !_script.hasAttribute('data-manual') &&\n        !_script.hasAttribute('data-lazy')\n      )\n        resizeActivate(speccer);\n    }\n  }\n};\n","/* eslint no-console:0 */\nimport { cx, set } from '../../utils/classnames';\nimport { getRec } from '../../utils/position';\nimport { add as addStyles } from '../../utils/styles';\n\n/**\n * Create a marker element with an optional element type.\n *\n * @param {string} n - The element type.\n * @returns {HTMLElement} - The created marker element.\n *\n * @example\n * ```typescript\n * const marker = create('div');\n * document.body.appendChild(marker);\n * ```\n */\nexport const create = (n = 'span'): HTMLElement => {\n  const markElement = document.createElement(n);\n  const classNames = cx('ph-speccer speccer mark');\n\n  set(markElement, classNames);\n\n  return markElement;\n};\n\n/**\n * Create a marker element and add it to the body with styles matching a specified element.\n *\n * @param {HTMLElement} elementToMark - The target element to match styles with.\n * @returns {Promise<void>} - A promise that resolves after creating and styling the marker element.\n *\n * @example\n * ```typescript\n * const elementToMark = document.getElementById('target');\n * element(elementToMark);\n * ```\n */\nexport const element = async (elementToMark: HTMLElement): Promise<void> => {\n  if (!elementToMark) return;\n\n  const markElement = create();\n\n  document.body.appendChild(markElement);\n\n  const positionalStyles = await getRec(markElement, elementToMark);\n  const { left, top, height, width } = positionalStyles.absolute();\n  const markStyles = {\n    left: `${left}px`,\n    top: `${top}px`,\n    height: `${height}px`,\n    width: `${width}px`\n  };\n\n  await addStyles(markElement, markStyles);\n};\n","/* eslint no-console:0 */\n/**\n * Converts a number to a string with a specified number of decimal places.\n *\n * @param {string | number} number - The number to convert.\n * @param {number} decimals - The number of decimal places (default is 3).\n * @returns {string} - The formatted number as a string.\n *\n * @example\n * ```ts\n * // Convert a number to a string with 2 decimal places\n * const formattedNumber = decimal(12.3456, 2); // \"12.34\"\n * ```\n */\nexport const decimal = (number: string | number, decimals = 3): string =>\n  parseFloat(number + '').toFixed(decimals);\n","/* eslint no-console:0 */\nimport { set as setClassNames, cx } from '../../utils/classnames';\nimport { add as addStyles, get as getStyles } from '../../utils/styles';\n\nimport { position } from './utils/position';\nimport { template } from './utils/template';\n\n/**\n * Create a DOM element with provided HTML and optional CSS class names.\n *\n * @param {string} html - The HTML content to be set in the created element.\n * @param {string | null} area - The optional CSS class names to add.\n * @returns {HTMLElement} - The created DOM element.\n *\n * @example\n * ```ts\n * const htmlContent = '<p>This is some HTML content.</p>';\n * const cssClass = 'custom-class';\n * const createdElement = create(htmlContent, cssClass);\n * document.body.appendChild(createdElement);\n * ```\n */\nexport const create = (html: string, area: string | null): HTMLElement => {\n  const _el = document.createElement('div');\n  const _extra_class_names = {};\n\n  if (area !== null && area !== '') _extra_class_names[area] = true;\n\n  const _class_names = cx('ph-speccer speccer typography', _extra_class_names);\n\n  _el.innerHTML = html;\n\n  setClassNames(_el, _class_names);\n\n  return _el;\n};\n\n/**\n * Create a specced typography element for a given target element.\n *\n * @param {HTMLElement} targetEl - The target element to specc typography for.\n * @returns {Promise<void>} - A promise that resolves once typography element is created and positioned.\n *\n * @example\n * ```ts\n * const targetElement = document.querySelector('.target');\n * if (targetElement) {\n *   element(targetElement);\n * }\n * ```\n */\nexport const element = async (targetEl: HTMLElement): Promise<void> => {\n  if (!targetEl) return;\n\n  const _area: string | null = targetEl.getAttribute('data-speccer-typography');\n  const _target_styles = await getStyles(targetEl);\n\n  if (\n    _target_styles.display === 'none' ||\n    _target_styles.opacity === '0' ||\n    _target_styles.visibility === 'hidden'\n  )\n    return;\n\n  targetEl.classList.add('is-specced');\n\n  const _html = await template(targetEl);\n  const _speccer_el = create(_html, _area);\n\n  document.body.appendChild(_speccer_el);\n\n  const _position = await position(_area, targetEl, _speccer_el);\n\n  addStyles(_speccer_el, _position);\n};\n","import { getTypography } from '../../../utils/css';\nimport { get as getStyles } from '../../../utils/styles';\n\n/**\n * Generate a HTML string for typography styles of a target element.\n *\n * @param {HTMLElement} targetEl - The target element for which to generate typography styles.\n * @returns {Promise<string>} - A promise that resolves with the HTML string.\n *\n * @example\n * ```ts\n * const targetElement = document.getElementById('target');\n * const typographyStyles = await template(targetElement);\n * console.log(typographyStyles);\n * ```\n */\nexport const template = async (targetEl: HTMLElement): Promise<string> => {\n  const _target_styles = await getStyles(targetEl);\n  const _styles = getTypography(_target_styles);\n  const _line_height =\n    _styles.lineHeight !== 'normal'\n      ? parseInt(_styles.lineHeight, 10) / 16 + 'rem'\n      : 'normal';\n\n  return (\n    `\n` +\n    'font-styles: {' +\n    '<ul class=\"speccer-styles\">' +\n    `  <li><span class=\"property\">font-family:</span> ${_styles.fontFamily};</li>` +\n    `  <li><span class=\"property\">font-size:</span> ${_styles.fontSize} / ${\n      parseInt(_styles.fontSize, 10) / 16\n    }rem;</li>` +\n    `  <li><span class=\"property\">font-weight:</span> ${_styles.fontWeight};</li>` +\n    `  <li><span class=\"property\">font-variation-settings:</span> ${_styles.fontVariationSettings};</li>` +\n    `  <li><span class=\"property\">line-height:</span> ${_styles.lineHeight} / ${_line_height};</li>` +\n    `  <li><span class=\"property\">letter-spacing:</span> ${_styles.letterSpacing};</li>` +\n    `  <li><span class=\"property\">font-style:</span> ${_styles.fontStyle};</li>` +\n    '</ul>' +\n    '}'\n  );\n};\n","import { SpeccerAreaEnum } from '../../../types/enums/area';\nimport { pinSpace } from '../../../utils/css';\nimport { decimal } from '../../../utils/number';\nimport {\n  get_horizontal_center_of_els,\n  get_vertical_center_of_els,\n  offset\n} from '../../../utils/position';\n\n/**\n * Calculate the position for the speccer element relative to the target element.\n *\n * @param {string | null} area - The area information for positioning.\n * @param {HTMLElement} targetEl - The target element.\n * @param {HTMLElement} speccerEl - The speccer element to position.\n * @returns {Promise<{ left: string, top: string }>} - A promise that resolves with the calculated position.\n *\n * @example\n * ```ts\n * const targetElement = document.getElementById('target');\n * const speccerElement = document.getElementById('speccer');\n * const area = 'top';\n * const position = await position(area, targetElement, speccerElement);\n * console.log(position); // { left: '10px', top: '20px' }\n * ```\n */\nexport const position = async (\n  area: string | null,\n  targetEl: HTMLElement,\n  speccerEl: HTMLElement\n): Promise<{ left: string; top: string }> => {\n  const _target_rect = targetEl.getBoundingClientRect();\n  const SPECCER_PIN_SPACE = pinSpace(speccerEl);\n  const _speccer_el_rect = speccerEl.getBoundingClientRect();\n  const _el_offset = await offset(targetEl);\n  const _left_layout_position_left =\n    _el_offset.left - _speccer_el_rect.width - SPECCER_PIN_SPACE + 'px';\n  const _left_layout_position_top =\n    decimal(\n      get_vertical_center_of_els(_el_offset.top, _speccer_el_rect, _target_rect)\n    ) + 'px';\n  const _right_layout_position_left =\n    _el_offset.left + _target_rect.width + SPECCER_PIN_SPACE + 'px';\n  const _right_layout_position_top =\n    decimal(\n      get_vertical_center_of_els(_el_offset.top, _speccer_el_rect, _target_rect)\n    ) + 'px';\n  const _top_layout_position_left =\n    decimal(\n      get_horizontal_center_of_els(\n        _el_offset.left,\n        _speccer_el_rect,\n        _target_rect\n      )\n    ) + 'px';\n  const _top_layout_position_top =\n    _el_offset.top - _speccer_el_rect.height - SPECCER_PIN_SPACE + 'px';\n  const _bottom_layout_position_left =\n    decimal(\n      get_horizontal_center_of_els(\n        _el_offset.left,\n        _speccer_el_rect,\n        _target_rect\n      )\n    ) + 'px';\n  const _bottom_layout_position_top =\n    _el_offset.top + _target_rect.height + SPECCER_PIN_SPACE + 'px';\n\n  let _position = {\n    left: _left_layout_position_left,\n    top: _left_layout_position_top\n  };\n\n  if (area?.includes(SpeccerAreaEnum.Right)) {\n    _position = {\n      left: _right_layout_position_left,\n      top: _right_layout_position_top\n    };\n  } else if (area?.includes(SpeccerAreaEnum.Top)) {\n    _position = {\n      left: _top_layout_position_left,\n      top: _top_layout_position_top\n    };\n  } else if (area?.includes(SpeccerAreaEnum.Bottom)) {\n    _position = {\n      left: _bottom_layout_position_left,\n      top: _bottom_layout_position_top\n    };\n  }\n\n  return _position;\n};\n","/* eslint-disable import/no-unused-modules */\n/* eslint no-console:0 */\nimport './types/interfaces/global';\nimport { dom, lazy, manual, activate } from './config/browser';\nimport {\n  create as dissectCreate,\n  element as dissectElement\n} from './features/dissect';\nimport { create as markCreate, element as markElement } from './features/mark';\nimport {\n  create as measureCreate,\n  element as measureElement\n} from './features/measure';\nimport {\n  create as spacingCreate,\n  element as spacingElement\n} from './features/spacing';\nimport {\n  create as typographyCreate,\n  element as typographyElement\n} from './features/typography';\nimport { removeAll } from './utils/node';\n\nexport const spacing = {\n  create: spacingCreate,\n  element: spacingElement\n};\n\nexport const dissect = {\n  create: dissectCreate,\n  element: dissectElement\n};\n\nexport const measure = {\n  create: measureCreate,\n  element: measureElement\n};\n\nexport const mark = {\n  create: markCreate,\n  element: markElement\n};\n\nexport const typography = {\n  create: typographyCreate,\n  element: typographyElement\n};\n\nexport const modes = {\n  dom,\n  lazy,\n  manual,\n  activate\n};\n\nconst speccer = () => {\n  removeAll('.ph-speccer.speccer');\n\n  const elsToBeSpecced = document.querySelectorAll(\n    '[data-speccer],[data-speccer] *:not(td):not(tr):not(th):not(tfoot):not(thead):not(tbody)'\n  );\n  const elsToBeMeasured = document.querySelectorAll('[data-speccer-measure]');\n  const elsToBeTypographySpecced = document.querySelectorAll(\n    '[data-speccer-typography]'\n  );\n  const elsToBeDissected = document.querySelectorAll('[data-anatomy-section]');\n  const elsToBeMarked = document.querySelectorAll('[data-speccer-mark]');\n\n  for (const el of elsToBeMarked) {\n    markElement(el as HTMLElement);\n  }\n  for (const el of elsToBeSpecced) {\n    spacingElement(el as HTMLElement);\n  }\n  for (const el of elsToBeMeasured) {\n    measureElement(el as HTMLElement);\n  }\n  for (const el of elsToBeTypographySpecced) {\n    typographyElement(el as HTMLElement);\n  }\n  for (const el of elsToBeDissected) {\n    dissectElement(el as HTMLElement);\n  }\n};\n\nexport default speccer;\n\nactivate(speccer);\n","/**\n * Inserts an HTML element after another element in the DOM.\n *\n * @param {HTMLElement|null} el - The reference element after which the new element will be inserted.\n * @param {HTMLElement} newSibling - The new element to be inserted.\n * @returns {Element|undefined|null}\n *\n * @example\n * ```ts\n * // Insert an element after another element\n * const referenceElement = document.getElementById('reference-element');\n * const newElement = document.createElement('div');\n * after(referenceElement, newElement);\n */\nexport const after = (\n  el: HTMLElement | null,\n  newSibling: HTMLElement\n): Element | undefined | null =>\n  el?.insertAdjacentElement('afterend', newSibling);\n\n/**\n * Removes all elements matching a selector from the DOM.\n *\n * @param {string} selector - The CSS selector used to select elements for removal.\n * @param {Document} el - The document context (default is the global `document` object).\n * @returns {void}\n *\n * @example\n * ```ts\n * // Remove all elements with a specific class from the document\n * removeAll('.my-class');\n * ```\n */\nexport const removeAll = (selector: string, el: Document = document): void => {\n  [].forEach.call(el.querySelectorAll(selector), function (e: HTMLElement) {\n    e.remove();\n  });\n};\n"],"names":["SpeccerAreaEnum","DissectAreaEnum","MeasureAreaEnum","getAreasFromString","areaString","split","isRightArea","includes","Right","isBottomArea","Bottom","isFullArea","Full","isEncloseArea","Enclose","isCurly","Curly","isString","variable","isNotString","isNumber","isNotNumber","isUndefined","waitForFrame","Promise","requestAnimationFrame","coords","rect","top","left","width","height","xy","center","x","y","right","bottom","intrinsic_coords","async","el","pos","Error","_allowed_positions","join","_el_rect","getBoundingClientRect","getCoordsPairFromObjects","el1","el2","pos1","pos2","x1","y1","x2","y2","createBezierCurveCoordinates","options","direct","firstSet","direction","firstControl","lastControl","firstPoint","lastPoint","getCurlySVGPath","startEl","stopEl","x2modifier","y2modifier","document","documentElement","scrollTop","direction_of_element","start","stop","crude","_angle","cx","cy","ex","ey","normalize","SyntaxError","TypeError","dy","dx","theta","Math","atan2","PI","angle","degrees","RangeError","cardinal_direction_crude","cardinal_direction","uniqueID","random","toString","substring","add","styles","Array","isArray","length","Object","keys","constructor","style","key","value","get","getComputedStyle","DrawSVGCurlyBracket","canvas","originalPathElement","startElement","stopElement","firstPathElement","secondPathElement","this","init","body","contains","getElementById","addStyle","scrollHeight","connect","draw","getPathElement","path","_path_el_id","_new_path","cloneNode","dataStartElID","getAttribute","setAttribute","classList","remove","_first_path_element","_second_path_element","parentNode","insertBefore","nextSibling","_direction","path1pos1","path1pos2","path2pos1","path2pos2","getPositionsForCurlySVGPath","_first_path_d","_second_path_d","window","DrawSVGLine","line","getPositionsForSVGPath","_d","getSVGPath","set","cls","avoid","trim","filter","cl","forEach","cls_obj","classname","SPECCER_LITERALS","getNumberValue","parseInt","getClassNameFromCSSProperty","property","replace","pinSpace","getPropertyValue","get_horizontal_center_of_els","modifier","startRect","targetRect","get_vertical_center_of_els","offset","targetEl","_target_rect","_el_offset_top","scrollY","_el_offset_left","scrollX","getRec","sourceEl","_source_rect","_target_offset","_target_offset_center","offsetWithCenter","_target_height","_target_width","_source_height","_source_width","absolute","toTop","sourceHeight","fromTop","toBottom","targetHeight","fromBottom","toLeft","sourceWidth","fromLeft","toRight","targetWidth","fromRight","area","dissectionEl","SPECCER_PIN_SPACE","SPECCER_MEASURE_SIZE","_positional_styles","Left","create","textContent","n","_el","createElement","_text_node","createTextNode","_extra_class_names","appendChild","_class_names","setClassNames","element","sectionEl","_dissection_els","querySelectorAll","_index_to_use","targetIndex","entries","_areas_string","Outline","_literal_to_use","toLowerCase","_dissection_el","_dissection_styles","SVG","text","tag","_target_styles","getStyles","display","opacity","visibility","Width","_measure_el","addStyles","SPECCER_DEFAULT_MEASURE_SIZE","Height","isHeightArea","position","spacingEl","_text_content","_target_spacing_styles","marginTop","marginBottom","marginLeft","marginRight","paddingTop","paddingBottom","paddingLeft","paddingRight","getSpacing","_target_pruned_spacing_styles","_value","_speccer_el","_class_name","activate","speccer","speccerEventFunc","func","wait","immediate","timeout","context","args","callNow","clearTimeout","setTimeout","apply","debounce","removeEventListener","addEventListener","dom","readyState","lazy","_spec_observer","IntersectionObserver","els","observer","intersectionRatio","specElement","target","unobserve","observe","_measure_observer","measureElement","_dissect_observer","dissectElement","manual","_script","currentScript","_speccer_script_src","hasAttribute","resizeActivate","markElement","classNames","elementToMark","positionalStyles","markStyles","decimal","number","decimals","parseFloat","toFixed","html","innerHTML","_area","_html","_styles","lineHeight","letterSpacing","fontFamily","fontSize","fontStyle","fontVariationSettings","fontWeight","getTypography","_line_height","template","_position","speccerEl","_speccer_el_rect","_el_offset","_left_layout_position_left","_left_layout_position_top","_right_layout_position_left","_right_layout_position_top","_top_layout_position_left","_top_layout_position_top","_bottom_layout_position_left","_bottom_layout_position_top","Top","spacing","spacingCreate","spacingElement","dissect","dissectCreate","measure","measureCreate","mark","markCreate","typography","typographyCreate","typographyElement","modes","selector","call","e","removeAll","elsToBeSpecced","elsToBeMeasured","elsToBeTypographySpecced","elsToBeDissected","elsToBeMarked"],"mappings":"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"}